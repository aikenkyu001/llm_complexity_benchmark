{
  "task_name": "longest_common_subsequence",
  "model": "qwen2.5-coder:14b",
  "timestamp": "2026-02-25T11:30:32.001349",
  "nl_problem": "# Task: longest_common_subsequence\n# Interface:\nClass: Solution\nMethod: longestCommonSubsequence(self, arg1, arg2)\n\nGiven two strings text1 and text2, return the length of their longest common subsequence.\nA subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.\nFor example, \"ace\" is a subsequence of \"abcde\".\nA common subsequence of two strings is a subsequence that is common to both strings.\nIf there is no common subsequence, return 0.\n\nConstraints:\n- 1 <= text1.length, text2.length <= 1000\n- text1 and text2 consist of only lowercase English characters.",
  "lisp_spec": "(task\n  (name \"longestCommonSubsequence\")\n  (signature ( (text1 string) (text2 string) ) int)\n  (constraints\n    (constraint \"1 <= length(text1), length(text2) <= 1000\")\n    (constraint \"text1 and text2 consist of only lowercase English characters.\")\n  )\n  (goal\n    (description \"Find the length of the longest common subsequence between two given strings, text1 and text2.\")\n    (rule \"A subsequence is a sequence derived from another sequence where some elements may be deleted without changing the order of the remaining elements.\")\n    (return \"Return the length of the longest common subsequence. If there is no common subsequence, return 0.\")\n  )\n)",
  "generated_code": "# solution.py\nfrom typing import List, Optional, Dict, Set, Any\n\nclass Solution:\n    def longestCommonSubsequence(self, text1: str, text2: str) -> int:\n        m, n = len(text1), len(text2)\n        \n        # Create a 2D DP array initialized to 0\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        \n        # Fill the DP table\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if text1[i - 1] == text2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        \n        # The length of the longest common subsequence is in dp[m][n]\n        return dp[m][n]",
  "test_passed": true,
  "test_output": "============================= test session starts ==============================\nplatform darwin -- Python 3.14.3, pytest-9.0.2, pluggy-1.6.0\nrootdir: /private/test/llm_complexity_benchmark\nplugins: anyio-4.12.1\ncollected 5 items\n\n01_TestDefinitions/longest_common_subsequence/test_solution.py .....     [100%]\n\n============================== 5 passed in 0.02s ===============================\n",
  "test_errors": "",
  "complexity_metrics": {
    "total_complexity_score": 0.2855,
    "python": {
      "cyclomatic_avg": 5.0,
      "cyclomatic_max": 5,
      "wmc": 5,
      "maintainability_index": 87.65895204825911,
      "max_nesting_depth": 5,
      "halstead_volume": 0,
      "lloc": 12,
      "loc": 20
    },
    "lisp": {
      "lisp_max_depth": 4,
      "lisp_constraints": 3,
      "lisp_rules": 1,
      "lisp_token_count": 90
    }
  }
}