{
  "task_name": "matrix_chain_multiplication",
  "model": "qwen2.5-coder:14b",
  "timestamp": "2026-02-25T11:34:54.927559",
  "nl_problem": "# Task: matrix_chain_multiplication\n# Interface:\nClass: Solution\nMethod: matrixChainOrder(self, arg1)\n\nGiven a list of matrix dimensions, find the minimum number of scalar multiplications needed to multiply the sequence of matrices.\nIf the sequence of matrices is A1, A2, ..., An, where Ai has dimensions `p[i-1] x p[i]`, the input is the list `p = [p0, p1, ..., pn]`.\n\nConstraints:\n- 2 <= p.length <= 100\n- 1 <= p[i] <= 100",
  "lisp_spec": "(task\n  (name \"matrixChainOrder\")\n  (signature ((arg1 (list int))) int)\n  (constraints\n    (constraint \"The length of arg1 must be between 2 and 100.\")\n    (constraint \"Each element in arg1 must be between 1 and 100.\")\n  )\n  (goal\n    (description \"Find the minimum number of scalar multiplications needed to multiply a sequence of matrices given their dimensions.\")\n    (rule \"The input list arg1 represents the dimensions of the matrices, where the i-th matrix has dimensions p[i-1] x p[i].\")\n    (return \"Return an integer representing the minimum number of scalar multiplications required.\")\n  )\n)",
  "generated_code": "class Solution:\n    def matrixChainOrder(self, p: List[int]) -> int:\n        n = len(p)\n        \n        # Create a table to store results of subproblems\n        dp = [[0 for _ in range(n)] for _ in range(n)]\n        \n        # L is chain length. The value of L increases from 2 to n-1.\n        for L in range(2, n):\n            # i is the starting index of the subarray\n            for i in range(1, n - L + 1):\n                j = i + L - 1\n                dp[i][j] = float('inf')\n                \n                # q is used to store the result of subproblems\n                for k in range(i, j):\n                    q = dp[i][k] + dp[k + 1][j] + p[i - 1] * p[k] * p[j]\n                    \n                    if q < dp[i][j]:\n                        dp[i][j] = q\n        \n        # The result is stored in dp[1][n-1]\n        return dp[1][n - 1]",
  "test_passed": true,
  "test_output": "============================= test session starts ==============================\nplatform darwin -- Python 3.14.3, pytest-9.0.2, pluggy-1.6.0\nrootdir: /private/test/llm_complexity_benchmark\nplugins: anyio-4.12.1\ncollected 2 items\n\n01_TestDefinitions/matrix_chain_multiplication/test_solution.py ..       [100%]\n\n============================== 2 passed in 0.02s ===============================\n",
  "test_errors": "",
  "complexity_metrics": {
    "total_complexity_score": 0.3345,
    "python": {
      "cyclomatic_avg": 7.0,
      "cyclomatic_max": 7,
      "wmc": 7,
      "maintainability_index": 87.28118355188325,
      "max_nesting_depth": 6,
      "halstead_volume": 0,
      "lloc": 13,
      "loc": 23
    },
    "lisp": {
      "lisp_max_depth": 5,
      "lisp_constraints": 3,
      "lisp_rules": 1,
      "lisp_token_count": 85
    }
  }
}