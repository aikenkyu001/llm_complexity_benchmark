{
  "task_name": "regex_matcher",
  "model": "qwen2.5-coder:14b",
  "timestamp": "2026-02-25T11:43:34.932287",
  "nl_problem": "# Task: regex_matcher\n# Interface:\nClass: Solution\nMethod: isMatch(self, arg1, arg2)\n\nGiven an input string s and a pattern p, implement regular expression matching with support for '.' and '*' where:\n- '.' Matches any single character.\u200b\u200b\u200b\u200b\n- '*' Matches zero or more of the preceding element.\nThe matching should cover the entire input string (not partial).\n\nConstraints:\n- 1 <= s.length <= 20\n- 1 <= p.length <= 20\n- s contains only lowercase English letters.\n- p contains only lowercase English letters, '.', and '*'.\n- It is guaranteed for each appearance of the character '*', there will be a previous valid character to match.",
  "lisp_spec": "(task\n  (name \"isMatch\")\n  (signature ( (s string) (p string) ) bool)\n  (constraints\n    (constraint \"1 <= s.length <= 20\")\n    (constraint \"1 <= p.length <= 20\")\n    (constraint \"s contains only lowercase English letters.\")\n    (constraint \"p contains only lowercase English letters, '.', and '*'.\")\n    (constraint \"For each appearance of the character '*', there will be a previous valid character to match.\")\n  )\n  (goal\n    (description \"Implement regular expression matching with support for '.' and '*' where '.' matches any single character and '*' matches zero or more of the preceding element. The matching should cover the entire input string (not partial).\")\n    (rule \"'.' Matches any single character.\")\n    (rule \"'*' Matches zero or more of the preceding element.\")\n    (return \"Return true if the input string s matches the pattern p, otherwise return false.\")\n  )\n)",
  "generated_code": "class Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        \"\"\"\n        Implement regular expression matching with support for '.' and '*'.\n        \n        :param s: Input string to match.\n        :param p: Pattern string containing '.', '*', and lowercase English letters.\n        :return: True if the input string matches the pattern, otherwise False.\n        \"\"\"\n        # Create a DP table where dp[i][j] is True if s[:i] matches p[:j]\n        dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)]\n        \n        # Base case: empty string matches empty pattern\n        dp[0][0] = True\n        \n        # Handle patterns like a*, a*b*, a*b*c* etc.\n        for j in range(2, len(p) + 1):\n            if p[j - 1] == '*':\n                dp[0][j] = dp[0][j - 2]\n        \n        # Fill the DP table\n        for i in range(1, len(s) + 1):\n            for j in range(1, len(p) + 1):\n                if p[j - 1] == '.' or p[j - 1] == s[i - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n                elif p[j - 1] == '*':\n                    # '*' can match zero or more of the preceding element\n                    dp[i][j] = dp[i][j - 2]  # Match zero elements\n                    if p[j - 2] == '.' or p[j - 2] == s[i - 1]:\n                        dp[i][j] |= dp[i - 1][j]  # Match one or more elements\n        \n        return dp[len(s)][len(p)]",
  "test_passed": true,
  "test_output": "============================= test session starts ==============================\nplatform darwin -- Python 3.14.3, pytest-9.0.2, pluggy-1.6.0\nrootdir: /private/test/llm_complexity_benchmark\nplugins: anyio-4.12.1\ncollected 2 items\n\n01_TestDefinitions/regex_matcher/test_solution.py ..                     [100%]\n\n============================== 2 passed in 0.02s ===============================\n",
  "test_errors": "",
  "complexity_metrics": {
    "total_complexity_score": 0.49850000000000005,
    "python": {
      "cyclomatic_avg": 11.0,
      "cyclomatic_max": 11,
      "wmc": 11,
      "maintainability_index": 81.1101288217716,
      "max_nesting_depth": 7,
      "halstead_volume": 0,
      "lloc": 17,
      "loc": 32
    },
    "lisp": {
      "lisp_max_depth": 4,
      "lisp_constraints": 6,
      "lisp_rules": 2,
      "lisp_token_count": 130
    }
  }
}