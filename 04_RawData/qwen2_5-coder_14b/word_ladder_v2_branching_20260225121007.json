{
  "task_name": "word_ladder_v2_branching",
  "model": "qwen2.5-coder:14b",
  "timestamp": "2026-02-25T12:10:07.894112",
  "nl_problem": "# Task: word_ladder_v2_branching\n# Interface:\nClass: Solution\nMethod: ladderLength(self, arg1, arg2, arg3)\n\nGiven two words, beginWord and endWord, and a dictionary's word list, find the length of the shortest transformation sequence from beginWord to endWord.\nThis is a complex version with multiple additional rules:\n1. You MUST use a Bidirectional BFS to minimize the search space.\n2. For each word transformation, you must check a 'forbidden_combinations' list (not provided, assume a helper `is_forbidden(word1, word2)` exists or handle it as a potential constraint).\n3. The wordList can be very large; prioritize memory efficiency.\n4. Return 0 if no path exists.\n\nConstraints:\n- Word length up to 20.\n- wordList size up to 10^5.\n- beginWord and endWord are different.",
  "lisp_spec": "(task\n  (name \"ladderLength\")\n  (signature ((beginWord string) (endWord string) (wordList list)) int)\n  (constraints\n    (constraint \"The word length is up to 20.\")\n    (constraint \"The wordList size is up to 10^5.\")\n    (constraint \"beginWord and endWord are different.\")\n    (constraint \"A helper function `is_forbidden(word1, word2)` exists to check forbidden combinations.\")\n  )\n  (goal\n    (description \"Find the length of the shortest transformation sequence from beginWord to endWord using Bidirectional BFS.\")\n    (rule \"Use Bidirectional BFS to minimize the search space.\")\n    (rule \"Check each word transformation against a 'forbidden_combinations' list.\")\n    (rule \"Prioritize memory efficiency given the potentially large size of wordList.\")\n    (return \"Return 0 if no path exists between beginWord and endWord.\")\n  )\n)",
  "generated_code": "from typing import List, Set, Dict\n\nclass Solution:\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\n        if endWord not in wordList:\n            return 0\n        \n        # Helper function to check if two words differ by exactly one character\n        def is_forbidden(word1: str, word2: str) -> bool:\n            diff_count = 0\n            for c1, c2 in zip(word1, word2):\n                if c1 != c2:\n                    diff_count += 1\n                    if diff_count > 1:\n                        return True\n            return False\n        \n        # Initialize the bidirectional BFS\n        forward_queue = collections.deque([beginWord])\n        backward_queue = collections.deque([endWord])\n        forward_visited = {beginWord}\n        backward_visited = {endWord}\n        level = 2\n        \n        while forward_queue and backward_queue:\n            if len(forward_queue) > len(backward_queue):\n                forward_queue, backward_queue = backward_queue, forward_queue\n                forward_visited, backward_visited = backward_visited, forward_visited\n            \n            for _ in range(len(forward_queue)):\n                current_word = forward_queue.popleft()\n                \n                # Generate all possible one-character transformations\n                for i in range(len(current_word)):\n                    for j in 'abcdefghijklmnopqrstuvwxyz':\n                        next_word = current_word[:i] + j + current_word[i+1:]\n                        \n                        if next_word in backward_visited:\n                            return level\n                        \n                        if next_word in wordList and next_word not in forward_visited:\n                            if not is_forbidden(current_word, next_word):\n                                forward_queue.append(next_word)\n                                forward_visited.add(next_word)\n            \n            level += 1\n        \n        return 0",
  "test_passed": false,
  "test_output": "============================= test session starts ==============================\nplatform darwin -- Python 3.14.3, pytest-9.0.2, pluggy-1.6.0\nrootdir: /private/test/llm_complexity_benchmark\nplugins: anyio-4.12.1\ncollected 2 items\n\n01_TestDefinitions/word_ladder_v2_branching/test_solution.py FF          [100%]\n\n=================================== FAILURES ===================================\n__________________________ test_word_ladder_v2_basic ___________________________\n\n    def test_word_ladder_v2_basic():\n        solution = Solution()\n        beginWord = \"hit\"\n        endWord = \"cog\"\n        wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\n>       assert solution.ladderLength(beginWord, endWord, wordList) == 5\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n01_TestDefinitions/word_ladder_v2_branching/test_solution.py:9: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <solution.Solution object at 0x103ff70e0>, beginWord = 'hit'\nendWord = 'cog', wordList = ['hot', 'dot', 'dog', 'lot', 'log', 'cog']\n\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\n        if endWord not in wordList:\n            return 0\n    \n        # Helper function to check if two words differ by exactly one character\n        def is_forbidden(word1: str, word2: str) -> bool:\n            diff_count = 0\n            for c1, c2 in zip(word1, word2):\n                if c1 != c2:\n                    diff_count += 1\n                    if diff_count > 1:\n                        return True\n            return False\n    \n        # Initialize the bidirectional BFS\n>       forward_queue = collections.deque([beginWord])\n                        ^^^^^^^^^^^\nE       NameError: name 'collections' is not defined. Did you forget to import 'collections'?\n\n01_TestDefinitions/word_ladder_v2_branching/solution.py:19: NameError\n___________________________ test_word_ladder_v2_long ___________________________\n\n    def test_word_ladder_v2_long():\n        solution = Solution()\n        beginWord = \"aaaaa\"\n        endWord = \"bbbbb\"\n        wordList = [\"aaaab\",\"aaabb\",\"aabbb\",\"abbbb\",\"bbbbb\"]\n>       assert solution.ladderLength(beginWord, endWord, wordList) == 6\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n01_TestDefinitions/word_ladder_v2_branching/test_solution.py:16: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <solution.Solution object at 0x104061310>, beginWord = 'aaaaa'\nendWord = 'bbbbb', wordList = ['aaaab', 'aaabb', 'aabbb', 'abbbb', 'bbbbb']\n\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\n        if endWord not in wordList:\n            return 0\n    \n        # Helper function to check if two words differ by exactly one character\n        def is_forbidden(word1: str, word2: str) -> bool:\n            diff_count = 0\n            for c1, c2 in zip(word1, word2):\n                if c1 != c2:\n                    diff_count += 1\n                    if diff_count > 1:\n                        return True\n            return False\n    \n        # Initialize the bidirectional BFS\n>       forward_queue = collections.deque([beginWord])\n                        ^^^^^^^^^^^\nE       NameError: name 'collections' is not defined. Did you forget to import 'collections'?\n\n01_TestDefinitions/word_ladder_v2_branching/solution.py:19: NameError\n=========================== short test summary info ============================\nFAILED 01_TestDefinitions/word_ladder_v2_branching/test_solution.py::test_word_ladder_v2_basic\nFAILED 01_TestDefinitions/word_ladder_v2_branching/test_solution.py::test_word_ladder_v2_long\n============================== 2 failed in 0.03s ===============================\n",
  "test_errors": "",
  "complexity_metrics": {
    "total_complexity_score": 0.531,
    "python": {
      "cyclomatic_avg": 12.0,
      "cyclomatic_max": 12,
      "wmc": 12,
      "maintainability_index": 64.62777232255989,
      "max_nesting_depth": 8,
      "halstead_volume": 0,
      "lloc": 36,
      "loc": 48
    },
    "lisp": {
      "lisp_max_depth": 4,
      "lisp_constraints": 5,
      "lisp_rules": 3,
      "lisp_token_count": 105
    }
  }
}