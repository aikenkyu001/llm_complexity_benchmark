{
  "task_name": "word_ladder",
  "model": "qwen2.5-coder:14b",
  "timestamp": "2026-02-25T12:09:01.525755",
  "nl_problem": "# Task: Word Ladder\n# Interface:\nClass: Solution\nMethod: ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int\n\n# Objective:\nA transformation sequence from word `beginWord` to word `endWord` using a dictionary `wordList` is a sequence of words `beginWord -> s1 -> s2 -> ... -> sk` such that:\n- Every adjacent pair of words differs by a single letter.\n- Every `si` for `1 <= i <= sk` is in `wordList`. Note that `beginWord` does not need to be in `wordList`.\n- `sk == endWord`.\nGiven two words, `beginWord` and `endWord`, and a dictionary `wordList`, return the number of words in the shortest transformation sequence from `beginWord` to `endWord`, or 0 if no such sequence exists.\n\n# Strategy Hint:\nUse Breadth-First Search (BFS) to find the shortest path. To efficiently find neighbors, consider pre-processing the word list or checking words with one-letter variations.\n\n# Constraints:\n- 1 <= beginWord.length <= 10\n- endWord.length == beginWord.length\n- 1 <= wordList.length <= 5000\n- wordList[i].length == beginWord.length\n- beginWord, endWord, and wordList[i] consist of lowercase English letters.\n- beginWord != endWord\n- All words in wordList are unique.",
  "lisp_spec": "(task\n  (name \"ladderLength\")\n  (signature ((beginWord string) (endWord string) (wordList list)) int)\n  (constraints\n    (constraint \"1 <= beginWord.length <= 10\")\n    (constraint \"endWord.length == beginWord.length\")\n    (constraint \"1 <= wordList.length <= 5000\")\n    (constraint \"wordList[i].length == beginWord.length\")\n    (constraint \"beginWord, endWord, and wordList[i] consist of lowercase English letters.\")\n    (constraint \"beginWord != endWord\")\n    (constraint \"All words in wordList are unique.\")\n  )\n  (goal\n    (description \"Find the number of words in the shortest transformation sequence from beginWord to endWord using the dictionary wordList.\")\n    (rule \"Every adjacent pair of words in the sequence must differ by a single letter.\")\n    (rule \"Every si for 1 <= i <= sk must be in wordList. Note that beginWord does not need to be in wordList.\")\n    (rule \"sk must equal endWord.\")\n    (return \"Return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.\")\n  )\n)",
  "generated_code": "from typing import List, Set\n\nclass Solution:\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\n        if endWord not in wordList:\n            return 0\n        \n        # Create a set for quick lookup of words in the word list\n        word_set = set(wordList)\n        \n        # Initialize BFS queue with the start word and level 1\n        queue = collections.deque([(beginWord, 1)])\n        \n        # Perform BFS\n        while queue:\n            current_word, level = queue.popleft()\n            \n            # Try to transform each character of the current word\n            for i in range(len(current_word)):\n                for c in 'abcdefghijklmnopqrstuvwxyz':\n                    next_word = current_word[:i] + c + current_word[i+1:]\n                    \n                    if next_word == endWord:\n                        return level + 1\n                    \n                    if next_word in word_set:\n                        queue.append((next_word, level + 1))\n                        word_set.remove(next_word)\n        \n        # If no transformation sequence is found\n        return 0",
  "test_passed": false,
  "test_output": "============================= test session starts ==============================\nplatform darwin -- Python 3.14.3, pytest-9.0.2, pluggy-1.6.0\nrootdir: /private/test/llm_complexity_benchmark\nplugins: anyio-4.12.1\ncollected 5 items\n\n01_TestDefinitions/word_ladder/test_solution.py F.FF.                    [100%]\n\n=================================== FAILURES ===================================\n____________________________ test_word_ladder_basic ____________________________\n\n    def test_word_ladder_basic():\n        \"\"\"\n        Test a basic case where a path exists.\n        \"\"\"\n        solution = Solution()\n        beginWord = \"hit\"\n        endWord = \"cog\"\n        wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\n        expected = 5\n>       assert solution.ladderLength(beginWord, endWord, wordList) == expected\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n01_TestDefinitions/word_ladder/test_solution.py:13: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <solution.Solution object at 0x103fa70e0>, beginWord = 'hit'\nendWord = 'cog', wordList = ['hot', 'dot', 'dog', 'lot', 'log', 'cog']\n\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\n        if endWord not in wordList:\n            return 0\n    \n        # Create a set for quick lookup of words in the word list\n        word_set = set(wordList)\n    \n        # Initialize BFS queue with the start word and level 1\n>       queue = collections.deque([(beginWord, 1)])\n                ^^^^^^^^^^^\nE       NameError: name 'collections' is not defined. Did you forget to import 'collections'?\n\n01_TestDefinitions/word_ladder/solution.py:12: NameError\n__________________________ test_word_ladder_same_word __________________________\n\n    def test_word_ladder_same_word():\n        \"\"\"\n        Test a case where begin and end words are the same.\n        \"\"\"\n        solution = Solution()\n        beginWord = \"hit\"\n        endWord = \"hit\"\n        wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\n        expected = 1\n>       assert solution.ladderLength(beginWord, endWord, wordList) == expected\nE       AssertionError: assert 0 == 1\nE        +  where 0 = ladderLength('hit', 'hit', ['hot', 'dot', 'dog', 'lot', 'log', 'cog'])\nE        +    where ladderLength = <solution.Solution object at 0x104011310>.ladderLength\n\n01_TestDefinitions/word_ladder/test_solution.py:35: AssertionError\n_________________________ test_word_ladder_short_list __________________________\n\n    def test_word_ladder_short_list():\n        \"\"\"\n        Test with a shorter word list.\n        \"\"\"\n        solution = Solution()\n        beginWord = \"a\"\n        endWord = \"c\"\n        wordList = [\"a\",\"b\",\"c\"]\n        expected = 2\n>       assert solution.ladderLength(beginWord, endWord, wordList) == expected\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n01_TestDefinitions/word_ladder/test_solution.py:46: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <solution.Solution object at 0x103fc3a80>, beginWord = 'a', endWord = 'c'\nwordList = ['a', 'b', 'c']\n\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\n        if endWord not in wordList:\n            return 0\n    \n        # Create a set for quick lookup of words in the word list\n        word_set = set(wordList)\n    \n        # Initialize BFS queue with the start word and level 1\n>       queue = collections.deque([(beginWord, 1)])\n                ^^^^^^^^^^^\nE       NameError: name 'collections' is not defined. Did you forget to import 'collections'?\n\n01_TestDefinitions/word_ladder/solution.py:12: NameError\n=========================== short test summary info ============================\nFAILED 01_TestDefinitions/word_ladder/test_solution.py::test_word_ladder_basic\nFAILED 01_TestDefinitions/word_ladder/test_solution.py::test_word_ladder_same_word\nFAILED 01_TestDefinitions/word_ladder/test_solution.py::test_word_ladder_short_list\n========================= 3 failed, 2 passed in 0.03s ==========================\n",
  "test_errors": "",
  "complexity_metrics": {
    "total_complexity_score": 0.48569999999999997,
    "python": {
      "cyclomatic_avg": 7.0,
      "cyclomatic_max": 7,
      "wmc": 7,
      "maintainability_index": 83.17387739497352,
      "max_nesting_depth": 6,
      "halstead_volume": 0,
      "lloc": 19,
      "loc": 31
    },
    "lisp": {
      "lisp_max_depth": 4,
      "lisp_constraints": 8,
      "lisp_rules": 3,
      "lisp_token_count": 141
    }
  }
}