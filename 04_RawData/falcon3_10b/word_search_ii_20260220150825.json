{
  "task_name": "word_search_ii",
  "model": "falcon3:10b",
  "timestamp": "2026-02-20T15:08:25.737220",
  "nl_problem": "# Task: word_search_ii\n# Interface:\nClass: Solution\nMethod: findWords(self, arg1, arg2)\n\nGiven an m x n board of characters and a list of strings words, return all words on the board.\nEach word must be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.\nYou should use a Trie data structure to optimize the search.\n\nConstraints:\n- m == board.length\n- n == board[i].length\n- 1 <= m, n <= 12\n- board and words consist of lowercase English letters.\n- 1 <= words.length <= 3 * 10^4\n- All strings in words are unique.",
  "lisp_spec": "(task\n (name \"findWords\")\n (signature ( (self) (arg1 (list (list char))) (arg2 (list string)) ) (list string))\n (constraints\n   (constraint \"m == board.length\")\n   (constraint \"n == board[i].length\")\n   (constraint \"1 <= m, n <= 12\")\n   (constraint \"board and words consist of lowercase English letters.\")\n   (constraint \"1 <= words.length <= 3 * 10^4\")\n   (constraint \"All strings in words are unique.\")\n )\n (goal\n   (description \"Given an m x n board of characters and a list of strings words, return all words on the board.\")\n   (rule \"Each word must be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.\")\n   (rule \"Use a Trie data structure to optimize the search.\")\n   (return \"A list of strings that are found on the board.\")\n )\n)",
  "generated_code": "from typing import List, Optional, Dict, Set, Any\n\nclass TrieNode:\n    def __init__(self):\n        self.children: Dict[str, 'TrieNode'] = {}\n        self.is_end: bool = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end = True\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end\n\nclass Solution:\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\n        trie = Trie()\n        for word in words:\n            trie.insert(word)\n\n        rows, cols = len(board), len(board[0])\n        visited = set()\n        result = set()\n\n        def dfs(r: int, c: int, node: TrieNode) -> None:\n            if (r < 0 or r >= rows or c < 0 or c >= cols or\n                (r, c) in visited or board[r][c] not in node.children):\n                return\n\n            visited.add((r, c))\n            node = node.children[board[r][c]]\n            if node.is_end:\n                result.add(board[r][c])\n\n            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                dfs(r + dr, c + dc, node)\n\n            visited.remove((r, c))\n\n        for r in range(rows):\n            for c in range(cols):\n                dfs(r, c, trie.root)\n\n        return list(result)",
  "test_passed": false,
  "test_output": "============================= test session starts ==============================\nplatform darwin -- Python 3.14.3, pytest-9.0.2, pluggy-1.6.0\nrootdir: /private/test/llm_complexity_benchmark\nplugins: anyio-4.12.1\ncollected 2 items\n\n01_TestDefinitions/word_search_ii/test_solution.py F.                    [100%]\n\n=================================== FAILURES ===================================\n__________________________ test_word_search_ii_basic ___________________________\n\n    def test_word_search_ii_basic():\n        solution = Solution()\n        board = [[\"o\",\"a\",\"a\",\"n\"],[\"e\",\"t\",\"a\",\"e\"],[\"i\",\"h\",\"k\",\"r\"],[\"i\",\"f\",\"l\",\"v\"]]\n        words = [\"oath\",\"pea\",\"eat\",\"rain\"]\n>       assert sorted(solution.findWords(board, words)) == sorted([\"eat\",\"oath\"])\nE       AssertionError: assert ['h', 't'] == ['eat', 'oath']\nE         \nE         At index 0 diff: 'h' != 'eat'\nE         Use -v to get more diff\n\n01_TestDefinitions/word_search_ii/test_solution.py:8: AssertionError\n=========================== short test summary info ============================\nFAILED 01_TestDefinitions/word_search_ii/test_solution.py::test_word_search_ii_basic\n========================= 1 failed, 1 passed in 0.03s ==========================\n",
  "test_errors": "",
  "complexity_metrics": {
    "total_complexity_score": 0.3572,
    "python": {
      "cyclomatic_avg": 2.4,
      "cyclomatic_max": 4,
      "wmc": 12,
      "maintainability_index": 45.88081605487782,
      "max_nesting_depth": 4,
      "halstead_volume": 0,
      "lloc": 46,
      "loc": 57
    },
    "lisp": {
      "lisp_max_depth": 6,
      "lisp_constraints": 7,
      "lisp_rules": 2,
      "lisp_token_count": 136
    }
  }
}