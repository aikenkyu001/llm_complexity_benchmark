{
  "task_name": "boggle_solver",
  "model": "falcon3:10b",
  "timestamp": "2026-02-20T14:54:33.668619",
  "nl_problem": "# Task: boggle_solver\n# Interface:\nClass: Solution\nMethod: findWords(self, arg1, arg2)\n\nGiven an m x n board of characters and a list of strings words, return all words on the board.\nEach word must be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.\n\nConstraints:\n- m == board.length\n- n == board[i].length\n- 1 <= m, n <= 12\n- 1 <= words.length <= 3 * 10^4\n- 1 <= words[i].length <= 10\n- board and words consist of lowercase English letters.\n- All strings in words are unique.",
  "lisp_spec": "(task\n (name \"findWords\")\n (signature ( (self) (board (list (list char))) (words (list string)) ) (list string))\n (constraints\n   (constraint \"m == board.length\")\n   (constraint \"n == board[i].length\")\n   (constraint \"1 <= m, n <= 12\")\n   (constraint \"1 <= words.length <= 3 * 10^4\")\n   (constraint \"1 <= words[i].length <= 10\")\n   (constraint \"board and words consist of lowercase English letters\")\n   (constraint \"All strings in words are unique\")\n )\n (goal\n   (description \"Return all words on the board that can be constructed from letters of sequentially adjacent cells.\")\n   (rule \"Each word must be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.\")\n   (return \"A list of strings representing the words found on the board.\")\n )\n)",
  "generated_code": "# solution.py\nfrom typing import List, Optional, Dict, Set, Any\nimport heapq\nimport collections\n\nclass TrieNode:\n    def __init__(self):\n        self.children = collections.defaultdict(TrieNode)\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for char in word:\n            node = node.children[char]\n        node.is_end_of_word = True\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end_of_word\n\nclass Solution:\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\n        trie = Trie()\n        for word in words:\n            trie.insert(word)\n\n        m, n = len(board), len(board[0])\n        visited = set()\n        result = set()\n\n        def dfs(i: int, j: int, node: TrieNode) -> None:\n            if (i < 0 or i >= m or j < 0 or j >= n or\n                (i, j) in visited or not board[i][j] in node.children):\n                return\n\n            visited.add((i, j))\n            node = node.children[board[i][j]]\n\n            if node.is_end_of_word:\n                result.add(board[i][j])\n\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                dfs(i + dx, j + dy, node)\n\n            visited.remove((i, j))\n\n        for i in range(m):\n            for j in range(n):\n                dfs(i, j, trie.root)\n\n        return list(result)",
  "test_passed": false,
  "test_output": "============================= test session starts ==============================\nplatform darwin -- Python 3.14.3, pytest-9.0.2, pluggy-1.6.0\nrootdir: /private/test/llm_complexity_benchmark\nplugins: anyio-4.12.1\ncollected 3 items\n\n01_TestDefinitions/boggle_solver/test_solution.py F.F                    [100%]\n\n=================================== FAILURES ===================================\n______________________________ test_boggle_basic _______________________________\n\n    def test_boggle_basic():\n        solution = Solution()\n        board = [[\"o\",\"a\",\"a\",\"n\"],[\"e\",\"t\",\"a\",\"e\"],[\"i\",\"h\",\"k\",\"r\"],[\"i\",\"f\",\"l\",\"v\"]]\n        words = [\"oath\",\"pea\",\"eat\",\"rain\"]\n        result = solution.findWords(board, words)\n>       assert sorted(result) == sorted([\"eat\",\"oath\"])\nE       AssertionError: assert ['h', 't'] == ['eat', 'oath']\nE         \nE         At index 0 diff: 'h' != 'eat'\nE         Use -v to get more diff\n\n01_TestDefinitions/boggle_solver/test_solution.py:9: AssertionError\n_____________________________ test_boggle_overlap ______________________________\n\n    def test_boggle_overlap():\n        solution = Solution()\n        board = [[\"a\",\"b\"],[\"a\",\"a\"]]\n        words = [\"aba\",\"baa\",\"aaa\",\"ab\"]\n        result = solution.findWords(board, words)\n>       assert sorted(result) == sorted([\"aaa\",\"aba\",\"baa\", \"ab\"])\nE       AssertionError: assert ['a', 'b'] == ['aaa', 'ab', 'aba', 'baa']\nE         \nE         At index 0 diff: 'a' != 'aaa'\nE         Right contains 2 more items, first extra item: 'aba'\nE         Use -v to get more diff\n\n01_TestDefinitions/boggle_solver/test_solution.py:22: AssertionError\n=========================== short test summary info ============================\nFAILED 01_TestDefinitions/boggle_solver/test_solution.py::test_boggle_basic\nFAILED 01_TestDefinitions/boggle_solver/test_solution.py::test_boggle_overlap\n========================= 2 failed, 1 passed in 0.03s ==========================\n",
  "test_errors": "",
  "complexity_metrics": {
    "total_complexity_score": 0.3558,
    "python": {
      "cyclomatic_avg": 2.2,
      "cyclomatic_max": 4,
      "wmc": 11,
      "maintainability_index": 55.40038155818652,
      "max_nesting_depth": 4,
      "halstead_volume": 0,
      "lloc": 44,
      "loc": 59
    },
    "lisp": {
      "lisp_max_depth": 6,
      "lisp_constraints": 8,
      "lisp_rules": 1,
      "lisp_token_count": 129
    }
  }
}