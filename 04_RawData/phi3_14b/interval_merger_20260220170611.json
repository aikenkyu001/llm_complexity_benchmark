{
  "task_name": "interval_merger",
  "model": "phi3:14b",
  "timestamp": "2026-02-20T17:06:11.294619",
  "nl_problem": "# Task: interval_merger\n# Interface:\nClass: Solution\nMethod: merge(self, arg1)\n\nGiven an array of intervals where `intervals[i] = [starti, endi]`, merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.\n\nConstraints:\n- 1 <= intervals.length <= 10^4\n- intervals[i].length == 2\n- 0 <= starti <= endi <= 10^4",
  "lisp_spec": "(task\n  (name \"merge\")\n  (signature ( (intervals listoflist) ) listoflist)\n  (constraints\n    (constraint \"The length of intervals is between 1 and 10^4.\")\n    (constraint \"Each interval has a length of 2.\")\n    (constraint \"Starting point of each interval is non-negative and less than or equal to ending point, which in turn is less than or equal to 10^4.\")\n  )\n  (goal\n    (description \"Merge all overlapping intervals from the given array and return an array of non-overlapping intervals that cover all input intervals.\")\n    (rule \"Sort the intervals based on their starting points.\")\n    (rule \"Iterate through sorted intervals, merging any overlapping ones by comparing endpoints.\")\n    (return \"The resulting list contains merged intervals with no overlap and covers all original intervals in the input array.\")\n  )\n)",
  "generated_code": "# solution.py\nfrom typing import List, Tuple\nimport heapq\n\nclass Interval:\n    def __init__(self, start: int, end: int):\n        self.start = start\n        self.end = end\n    \n    def merge(self, other) -> Optional['Interval']:\n        if (other.start >= self.end or other.end <= self.start):\n            return None\n        \n        new_start = min(self.start, other.start)\n        new_end = max(self.end, other.end)\n        return Interval(new_start, new_end)\n    \n    def __lt__(self, other: 'Interval') -> bool:\n        return self.end < other.end\n\nclass Solution:\n    @staticmethod\n    def merge(intervals: List[List[int]]) -> List[List[int]]:\n        if not intervals or len(intervals) == 0:\n            return []\n        \n        # Sort the intervals based on their starting points.\n        sorted_intervals = sorted(Interval(*i) for i in intervals)\n        \n        merged_intervals = [sorted_intervals[0]]\n        for interval in sorted_intervals[1:]:\n            last_merged_interval = merged_eintries[-1]\n            \n            # Merge any overlapping ones by comparing endpoints.\n            if (last_merged_interval.merge(interval) is not None):\n                merged_intervals[-1].end = interval.merge(last_merged_interval).end\n            else:\n                merged_intervals.append(Interval(*interval))\n        \n        # Return the resulting list containing merged intervals with no overlap and covers all original intervals in the input array.\n        return [[i.start, i.end] for i in merged_intervals]",
  "test_passed": false,
  "test_output": "============================= test session starts ==============================\nplatform darwin -- Python 3.14.3, pytest-9.0.2, pluggy-1.6.0\nrootdir: /private/test/llm_complexity_benchmark\nplugins: anyio-4.12.1\ncollected 3 items\n\n01_TestDefinitions/interval_merger/test_solution.py FF.                  [100%]\n\n=================================== FAILURES ===================================\n__________________________ test_interval_merge_basic ___________________________\n\n    def test_interval_merge_basic():\n        solution = Solution()\n        intervals = [[1,3],[2,6],[8,10],[15,18]]\n>       assert solution.merge(intervals) == [[1,6],[8,10],[15,18]]\n               ^^^^^^^^^^^^^^^^^^^^^^^^^\n\n01_TestDefinitions/interval_merger/test_solution.py:7: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nintervals = [[1, 3], [2, 6], [8, 10], [15, 18]]\n\n    @staticmethod\n    def merge(intervals: List[List[int]]) -> List[List[int]]:\n        if not intervals or len(intervals) == 0:\n            return []\n    \n        # Sort the intervals based on their starting points.\n        sorted_intervals = sorted(Interval(*i) for i in intervals)\n    \n        merged_intervals = [sorted_intervals[0]]\n        for interval in sorted_intervals[1:]:\n>           last_merged_interval = merged_eintries[-1]\n                                   ^^^^^^^^^^^^^^^\nE           NameError: name 'merged_eintries' is not defined\n\n01_TestDefinitions/interval_merger/solution.py:32: NameError\n_________________________ test_interval_merge_overlap __________________________\n\n    def test_interval_merge_overlap():\n        solution = Solution()\n        intervals = [[1,4],[4,5]]\n>       assert solution.merge(intervals) == [[1,5]]\n               ^^^^^^^^^^^^^^^^^^^^^^^^^\n\n01_TestDefinitions/interval_merger/test_solution.py:12: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nintervals = [[1, 4], [4, 5]]\n\n    @staticmethod\n    def merge(intervals: List[List[int]]) -> List[List[int]]:\n        if not intervals or len(intervals) == 0:\n            return []\n    \n        # Sort the intervals based on their starting points.\n        sorted_intervals = sorted(Interval(*i) for i in intervals)\n    \n        merged_intervals = [sorted_intervals[0]]\n        for interval in sorted_intervals[1:]:\n>           last_merged_interval = merged_eintries[-1]\n                                   ^^^^^^^^^^^^^^^\nE           NameError: name 'merged_eintries' is not defined\n\n01_TestDefinitions/interval_merger/solution.py:32: NameError\n=========================== short test summary info ============================\nFAILED 01_TestDefinitions/interval_merger/test_solution.py::test_interval_merge_basic\nFAILED 01_TestDefinitions/interval_merger/test_solution.py::test_interval_merge_overlap\n========================= 2 failed, 1 passed in 0.03s ==========================\n",
  "test_errors": "",
  "complexity_metrics": {
    "total_complexity_score": 0.3313,
    "python": {
      "cyclomatic_avg": 3.0,
      "cyclomatic_max": 7,
      "wmc": 12,
      "maintainability_index": 72.7901917456297,
      "max_nesting_depth": 4,
      "halstead_volume": 0,
      "lloc": 28,
      "loc": 41
    },
    "lisp": {
      "lisp_max_depth": 4,
      "lisp_constraints": 4,
      "lisp_rules": 2,
      "lisp_token_count": 119
    }
  }
}