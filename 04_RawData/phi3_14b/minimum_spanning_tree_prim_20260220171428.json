{
  "task_name": "minimum_spanning_tree_prim",
  "model": "phi3:14b",
  "timestamp": "2026-02-20T17:14:28.306753",
  "nl_problem": "# Task: minimum_spanning_tree_prim\n# Interface:\nClass: Solution\nMethod: primMST(self, graph: Dict[int, List[Tuple[int, int]]], n: int) -> int\n\nGiven a weighted, undirected connected graph with n vertices (labeled 0 to n-1), find the sum of the weights of the edges in its Minimum Spanning Tree using Prim's algorithm.\nThe graph is represented as an adjacency list: `graph[u] = [(v, weight), ...]` where u is the source node, v is the destination, and weight is the edge weight.\n\n# Important:\nThe function MUST accept TWO arguments: `graph` and `n`.\n\n# Implementation Hint:\nUse a priority queue (min-heap) to store edges or nodes. Initialize a `visited` array or set of size `n`. \nStart by marking node 0 as visited and adding its neighbors to the heap.\n\nConstraints:\n- 1 <= n <= 1000\n- 1 <= weight <= 1000",
  "lisp_spec": "(task\n  (name \"primMST\")\n  (signature ( (graph (dict int (list tuple))) (n int) ) int)\n  (constraints\n    (constraint \"The graph is weighted, undirected, and connected with n vertices.\")\n    (constraint \"1 <= n <= 1000\")\n    (constraint \"1 <= weight <= 1000\")\n  )\n  (goal\n    (description \"Find the sum of weights of edges in its Minimum Spanning Tree using Prim's algorithm.\")\n    (rule \"The graph is represented as an adjacency list: `graph[u] = [(v, weight), ...]` where u is the source node, v is the destination, and weight is the edge weight.\")\n    (return \"Return the sum of weights of edges in its Minimum Spanning Tree using Prim's algorithm. If there are multiple MSTs with equal total weight, return any one of them.\")\n  )\n)",
  "generated_code": "# solution.py\nfrom typing import List, Optional, Dict, Set, Any\nimport heapq\nimport collections\n\nclass Edge:\n    def __init__(self, to_node: int, weight: int):\n        self.to_node = to_node\n        self.weight = weight\n    \n    def __lt__(self, other):\n        return self.weight < other.weight\n\nclass Solution:\n    @staticmethod\n    def primMST(graph: Dict[int, List[Tuple[int, int]]], n: int) -> int:\n        if not graph or len(graph) != n:\n            raise ValueError(\"Invalid input\")\n        \n        visited = set()\n        edges_heap = []\n        start_node = next(iter(graph))  # Get the first node as starting point\n        total_weight = 0\n\n        while len(visited) < n:\n            if start_node not in visited:\n                heapq.heappush(edges_heap, Edge(start_node, 0))\n            \n            edge = heapq.heappop(edges_heap)\n            if edge.to_node not in visited:\n                total_weight += edge.weight\n                visited.add(edge.to_node)\n                \n                for neighbor, weight in graph[edge.to_node]:\n                    heapq.heappush(edges_heap, Edge(neighbor, weight))\n            \n            start_node = next((n for n in graph if n not in visited), None)  # Get the next unvisited node as starting point\n        \n        return total_weight",
  "test_passed": false,
  "test_output": "============================= test session starts ==============================\nplatform darwin -- Python 3.14.3, pytest-9.0.2, pluggy-1.6.0\nrootdir: /private/test/llm_complexity_benchmark\nplugins: anyio-4.12.1\ncollected 2 items\n\n01_TestDefinitions/minimum_spanning_tree_prim/test_solution.py FF        [100%]\n\n=================================== FAILURES ===================================\n_______________________________ test_prim_basic ________________________________\n\n    def test_prim_basic():\n        solution = Solution()\n        # graph[u] = [(v, weight), ...]\n        graph = {\n            0: [(1, 2), (3, 6)],\n            1: [(0, 2), (2, 3), (3, 8), (4, 5)],\n            2: [(1, 3), (4, 7)],\n            3: [(0, 6), (1, 8), (4, 9)],\n            4: [(1, 5), (2, 7), (3, 9)]\n        }\n        # MST Edges: (0,1,2), (1,2,3), (1,4,5), (0,3,6) -> Sum = 16\n>       assert solution.primMST(graph, 5) == 16\nE       assert 0 == 16\nE        +  where 0 = <function Solution.primMST at 0x106ac6980>({0: [(1, 2), (3, 6)], 1: [(0, 2), (2, 3), (3, 8), (4, 5)], 2: [(1, 3), (4, 7)], 3: [(0, 6), (1, 8), (4, 9)], ...}, 5)\nE        +    where <function Solution.primMST at 0x106ac6980> = <solution.Solution object at 0x106a330e0>.primMST\n\n01_TestDefinitions/minimum_spanning_tree_prim/test_solution.py:15: AssertionError\n_______________________________ test_prim_simple _______________________________\n\n    def test_prim_simple():\n        solution = Solution()\n        graph = {\n            0: [(1, 10)],\n            1: [(0, 10)]\n        }\n>       assert solution.primMST(graph, 2) == 10\nE       assert 0 == 10\nE        +  where 0 = <function Solution.primMST at 0x106ac6980>({0: [(1, 10)], 1: [(0, 10)]}, 2)\nE        +    where <function Solution.primMST at 0x106ac6980> = <solution.Solution object at 0x106a9d810>.primMST\n\n01_TestDefinitions/minimum_spanning_tree_prim/test_solution.py:23: AssertionError\n=========================== short test summary info ============================\nFAILED 01_TestDefinitions/minimum_spanning_tree_prim/test_solution.py::test_prim_basic\nFAILED 01_TestDefinitions/minimum_spanning_tree_prim/test_solution.py::test_prim_simple\n============================== 2 failed in 0.03s ===============================\n",
  "test_errors": "",
  "complexity_metrics": {
    "total_complexity_score": 0.3611,
    "python": {
      "cyclomatic_avg": 3.6666666666666665,
      "cyclomatic_max": 9,
      "wmc": 11,
      "maintainability_index": 70.31147897207043,
      "max_nesting_depth": 5,
      "halstead_volume": 0,
      "lloc": 29,
      "loc": 39
    },
    "lisp": {
      "lisp_max_depth": 6,
      "lisp_constraints": 4,
      "lisp_rules": 1,
      "lisp_token_count": 118
    }
  }
}