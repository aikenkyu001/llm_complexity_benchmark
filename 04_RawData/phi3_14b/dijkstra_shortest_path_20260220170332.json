{
  "task_name": "dijkstra_shortest_path",
  "model": "phi3:14b",
  "timestamp": "2026-02-20T17:03:32.222324",
  "nl_problem": "# Task: Dijkstra Shortest Path\n# Interface:\nClass: Solution\nMethod: dijkstra(self, graph: Dict[int, List[Tuple[int, int]]], start_node: int, n: int) -> List[float]\n\nGiven a weighted, undirected graph and a starting node, return the shortest distance to all other nodes from the source.\nThe graph is represented as an adjacency list: `graph[u] = [(v, weight), ...]`.\nIf a node is unreachable, the distance should be infinity (represented as a very large integer or float('inf')).\n\nConstraints:\n- The number of nodes is between 1 and 1000.\n- Weights are non-negative.",
  "lisp_spec": "(task\n  (name \"dijkstra\")\n  (signature ( (graph (dict int (list tuple))) (start_node int) (n int) ) (list float))\n  (constraints\n    (constraint \"The number of nodes is between 1 and 1000.\")\n    (constraint \"Weights are non-negative.\")\n  )\n  (goal\n    (description \"Return the shortest distance to all other nodes from the source in a weighted, undirected graph represented as an adjacency list: `graph[u] = [(v, weight), ...]`.\")\n    (rule \"If a node is unreachable, the distance should be infinity.\")\n    (return \"The return value will be a list of floats representing the shortest distances to all other nodes from the source. If a node is unreachable, its corresponding value in the list will be infinity or float('inf').\")\n  )\n)",
  "generated_code": "# solution.py\nfrom typing import List, Optional, Dict, Tuple, Set, Any\nimport heapq\nimport collections\n\nclass GraphNode:\n    def __init__(self, node_id: int):\n        self.node_id = node_id\n        self.adjacent_nodes: List[Tuple[int, float]] = []  # (node_id, weight)\n    \n    def add_edge(self, neighbor_id: int, weight: float):\n        self.adjacent_nodes.append((neighbor_eid, weight))\n        \nclass Graph:\n    def __init__(self):\n        self.node_map: Dict[int, GraphNode] = {}  # node_id -> GraphNode\n    \n    def add_edge(self, u: int, v: int, w: float) -> None:\n        if u not in self.node_map:\n            self.node_map[u] = GraphNode(u)\n        if v not in self.node_map:\n            self.node_map[v] = GraphNode(v)\n        \n        node_u, node_v = self.node_map[u], self.node_map[v]\n        node_u.add_edge(v, w)\n        node_v.add_edge(u, w)  # undirected graph\n    \n    def get_nodes(self) -> Set[int]:\n        return set(self.node_map.keys())\n        \nclass Solution:\n    @staticmethod\n    def dijkstra(graph: Dict[int, List[Tuple[int, float]]], start_node: int, n: int) -> List[float]:\n        if not 1 <= start_node <= n or len(graph) != n:\n            raise ValueError(\"Invalid input\")\n        \n        distances = [float('inf')] * n\n        visited = set()\n        queue = [(0, start_node)]\n        \n        while queue and len(visited) < n:\n            dist, node = heapq.heappop(queue)\n            \n            if node in visited:\n                continue\n                \n            distances[node - 1] = dist\n            visited.add(node)\n            \n            for neighbor_id, weight in graph[node]:\n                if neighbor_id not in visited:\n                    heapq.heappush(queue, (dist + weight, neighbor_id))\n        \n        return distances",
  "test_passed": false,
  "test_output": "============================= test session starts ==============================\nplatform darwin -- Python 3.14.3, pytest-9.0.2, pluggy-1.6.0\nrootdir: /private/test/llm_complexity_benchmark\nplugins: anyio-4.12.1\ncollected 2 items\n\n01_TestDefinitions/dijkstra_shortest_path/test_solution.py FF            [100%]\n\n=================================== FAILURES ===================================\n_____________________________ test_dijkstra_basic ______________________________\n\n    def test_dijkstra_basic():\n        solution = Solution()\n        # graph[u] = [(v, weight), ...]\n        graph = {\n            0: [(1, 4), (2, 1)],\n            1: [(3, 1)],\n            2: [(1, 2), (3, 5)],\n            3: []\n        }\n>       result = solution.dijkstra(graph, 0, 4)\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n01_TestDefinitions/dijkstra_shortest_path/test_solution.py:13: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ngraph = {0: [(1, 4), (2, 1)], 1: [(3, 1)], 2: [(1, 2), (3, 5)], 3: []}\nstart_node = 0, n = 4\n\n    @staticmethod\n    def dijkstra(graph: Dict[int, List[Tuple[int, float]]], start_node: int, n: int) -> List[float]:\n        if not 1 <= start_node <= n or len(graph) != n:\n>           raise ValueError(\"Invalid input\")\nE           ValueError: Invalid input\n\n01_TestDefinitions/dijkstra_shortest_path/solution.py:35: ValueError\n__________________________ test_dijkstra_unreachable ___________________________\n\n    def test_dijkstra_unreachable():\n        solution = Solution()\n        graph = {0: [(1, 2)], 1: [], 2: []}\n>       result = solution.dijkstra(graph, 0, 3)\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n01_TestDefinitions/dijkstra_shortest_path/test_solution.py:19: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ngraph = {0: [(1, 2)], 1: [], 2: []}, start_node = 0, n = 3\n\n    @staticmethod\n    def dijkstra(graph: Dict[int, List[Tuple[int, float]]], start_node: int, n: int) -> List[float]:\n        if not 1 <= start_node <= n or len(graph) != n:\n>           raise ValueError(\"Invalid input\")\nE           ValueError: Invalid input\n\n01_TestDefinitions/dijkstra_shortest_path/solution.py:35: ValueError\n=========================== short test summary info ============================\nFAILED 01_TestDefinitions/dijkstra_shortest_path/test_solution.py::test_dijkstra_basic\nFAILED 01_TestDefinitions/dijkstra_shortest_path/test_solution.py::test_dijkstra_unreachable\n============================== 2 failed in 0.03s ===============================\n",
  "test_errors": "",
  "complexity_metrics": {
    "total_complexity_score": 0.3272,
    "python": {
      "cyclomatic_avg": 2.5,
      "cyclomatic_max": 8,
      "wmc": 15,
      "maintainability_index": 64.20121377067295,
      "max_nesting_depth": 5,
      "halstead_volume": 0,
      "lloc": 42,
      "loc": 54
    },
    "lisp": {
      "lisp_max_depth": 6,
      "lisp_constraints": 3,
      "lisp_rules": 1,
      "lisp_token_count": 111
    }
  }
}