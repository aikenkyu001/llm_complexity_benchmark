{
  "task_name": "word_break",
  "model": "phi3:14b",
  "timestamp": "2026-02-20T17:47:26.311406",
  "nl_problem": "# Task: word_break\n# Interface:\nClass: Solution\nMethod: wordBreak(self, arg1, arg2, arg3)\n\nGiven a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of one or more dictionary words.\nNote that the same word in the dictionary may be reused multiple times in the segmentation.\n\nConstraints:\n- 1 <= s.length <= 300\n- 1 <= wordDict.length <= 1000\n- 1 <= wordDict[i].length <= 20\n- s and wordDict[i] consist of only lowercase English letters.\n- All strings in wordDict are unique.",
  "lisp_spec": "(task\n  (name \"wordBreak\")\n  (signature ((s string) (wordDict list))\n    (list bool))\n  (constraints\n    (constraint \"1 <= s.length <= 300\")\n    (constraint \"1 <= wordDict.length <= 1000\")\n    (constraint \"1 <= length(wordDict[i]) <= 20\")\n    (constraint \"s and wordDict[i] consist of only lowercase English letters.\")\n    (constraint \"All strings in wordDict are unique.\")\n  )\n  (goal\n    (description \"Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of one or more dictionary words. Note that the same word in the dictionary may be reused multiple times in the segmentation.\")\n    (rule \"The function should check all possible combinations of substrings from the input string to determine if it can be segmented using the given dictionary.\")\n    (return \"(bool)\"))",
  "generated_code": "class Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\n        # Create a set from the list to make lookup faster\n        words = set(wordDict)\n        \n        n = len(s)\n        dp = [False] * (n + 1)\n        dp[0] = True\n        \n        for i in range(1, n + 1):\n            for j in range(i):\n                if dp[j] and s[j:i] in words:\n                    dp[i] = True\n                    break\n            \n        return dp[-1]",
  "test_passed": true,
  "test_output": "============================= test session starts ==============================\nplatform darwin -- Python 3.14.3, pytest-9.0.2, pluggy-1.6.0\nrootdir: /private/test/llm_complexity_benchmark\nplugins: anyio-4.12.1\ncollected 4 items\n\n01_TestDefinitions/word_break/test_solution.py ....                      [100%]\n\n============================== 4 passed in 0.02s ===============================\n",
  "test_errors": "",
  "complexity_metrics": {
    "total_complexity_score": 0.35129999999999995,
    "python": {
      "cyclomatic_avg": 5.0,
      "cyclomatic_max": 5,
      "wmc": 5,
      "maintainability_index": 79.52274827041674,
      "max_nesting_depth": 5,
      "halstead_volume": 0,
      "lloc": 12,
      "loc": 16
    },
    "lisp": {
      "lisp_max_depth": 4,
      "lisp_constraints": 6,
      "lisp_rules": 1,
      "lisp_token_count": 119
    }
  }
}