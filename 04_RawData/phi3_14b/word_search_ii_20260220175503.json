{
  "task_name": "word_search_ii",
  "model": "phi3:14b",
  "timestamp": "2026-02-20T17:55:03.281167",
  "nl_problem": "# Task: word_search_ii\n# Interface:\nClass: Solution\nMethod: findWords(self, arg1, arg2)\n\nGiven an m x n board of characters and a list of strings words, return all words on the board.\nEach word must be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.\nYou should use a Trie data structure to optimize the search.\n\nConstraints:\n- m == board.length\n- n == board[i].length\n- 1 <= m, n <= 12\n- board and words consist of lowercase English letters.\n- 1 <= words.length <= 3 * 10^4\n- All strings in words are unique.",
  "lisp_spec": "(task\n  (name \"findWords\")\n  (signature ((board (list (list char))) (words (list string)) (trie Trie) ) list_of_strings)\n  (constraints\n    (constraint \"The board is a two-dimensional array with dimensions m x n.\")\n    (constraint \"Each cell in the board contains a single lowercase English letter.\")\n    (constraint \"words is a list of unique strings consisting of lowercase English letters.\")\n    (constraint \"1 <= m, n <= 12\")\n    (constraint \"The Trie data structure will be used to optimize the search for words on the board.\")\n  )\n  (goal\n    (description \"Find all words from the list that can be constructed by sequentially adjacent cells in the given board. Adjacent cells are horizontally or vertically neighboring, and each letter cell may not be used more than once per word.\")\n    (rule \"Words must be formed using letters of sequentially adjacent cells on the board.\")\n    (return \"A list of strings representing all words found on the board that can be constructed from sequentially adjacent cells. The order of the returned words does not matter, and duplicates should be avoided if possible.\")\n  )\n)",
  "generated_code": "lisp\n(task\n  (name \"findWords\")\n  (signature ((board (list (list char))) (words (list string)) (trie Trie) ) list_of_strings)\n  (constraints\n    (constraint \"The board is a two-dimensional array with dimensions m x n.\")\n    (constraint \"Each cell in the board contains a single lowercase English letter.\")\n    (constraint \"words is a list of unique strings consisting of lowercase English letters.\")\n    (constraint \"1 <= m, n <= 12\")\n    (constraint \"The Trie data structure will be used to optimize the search for words on the board.\")\n  )\n  (goal\n    (description \"Find all words from the list that can be constructed by sequentially adjacent cells in the given board. Adjacent cells are horizontally or vertically neighboring, and each letter cell may not be used more than once per word.\")\n    (rule \"Words must be formed using letters of sequentially adjacent cells on the board.\")\n    (return \"A list of strings representing all words found on the board that can be constructed from sequentially adjacent cells. The order of the returned words does not matter, and duplicates should be avoided if possible.\")\n  )\n)\n\n# solution.py\nfrom typing import List, Optional, Dict, Set, Any\nimport heapq\nimport collections\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_word = False\n        self.words = []\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n    \n    def insert(self, word: str) -> None:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_word = True\n    \n    def search(self, board: List[List[str]], i: int, j: int, trie_node: Optional[TrieNode], prefix: str) -> None:\n        if not (0 <= i < len(board)) or not (0 <= j < len(board[0])):\n            return\n        \n        char = board[i][j]\n        node = trie_node.children.get(char, None)\n        if not node:\n            return\n        \n        prefix += char\n        if node.is_word:\n            self.words.append(prefix)\n            \n        for di in [-1, 0, 1]:\n            for dj in [-1, 0, 1]:\n                if di == 0 and dj == 0:\n                    continue\n                new_i = i + di\n                new_j = j + dj\n                self.search(board, new_i, new_j, node, prefix)\n    \n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\n        m, n = len(board), len(board[0])\n        \n        self.words = []\n        for word in words:\n            self.insert(word)\n            \n        visited = [[False] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if board[i][j] not in self.root.children:\n                    continue\n                self.search(board, i, j, self.root, \"\")\n        \n        return list(set(self.words))\n    \nclass Solution:\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\n        trie = Trie()\n        return trie.findWords(board, words)",
  "test_passed": false,
  "test_output": "============================= test session starts ==============================\nplatform darwin -- Python 3.14.3, pytest-9.0.2, pluggy-1.6.0\nrootdir: /private/test/llm_complexity_benchmark\nplugins: anyio-4.12.1\ncollected 0 items / 1 error\n\n==================================== ERRORS ====================================\n_____ ERROR collecting 01_TestDefinitions/word_search_ii/test_solution.py ______\n../venv/lib/python3.14/site-packages/_pytest/python.py:507: in importtestmodule\n    mod = import_path(\n../venv/lib/python3.14/site-packages/_pytest/pathlib.py:587: in import_path\n    importlib.import_module(module_name)\n/opt/homebrew/Cellar/python@3.14/3.14.3_1/Frameworks/Python.framework/Versions/3.14/lib/python3.14/importlib/__init__.py:88: in import_module\n    return _bootstrap._gcd_import(name[level:], package, level)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n<frozen importlib._bootstrap>:1398: in _gcd_import\n    ???\n<frozen importlib._bootstrap>:1371: in _find_and_load\n    ???\n<frozen importlib._bootstrap>:1342: in _find_and_load_unlocked\n    ???\n<frozen importlib._bootstrap>:938: in _load_unlocked\n    ???\n../venv/lib/python3.14/site-packages/_pytest/assertion/rewrite.py:197: in exec_module\n    exec(co, module.__dict__)\n01_TestDefinitions/word_search_ii/test_solution.py:2: in <module>\n    from solution import Solution\nE     File \"/private/test/llm_complexity_benchmark/01_TestDefinitions/word_search_ii/solution.py\", line 3\nE       (name \"findWords\")\nE             ^^^^^^^^^^^\nE   SyntaxError: invalid syntax\n=========================== short test summary info ============================\nERROR 01_TestDefinitions/word_search_ii/test_solution.py\n!!!!!!!!!!!!!!!!!!!! Interrupted: 1 error during collection !!!!!!!!!!!!!!!!!!!!\n=============================== 1 error in 0.10s ===============================\n",
  "test_errors": "",
  "complexity_metrics": {
    "error": "invalid syntax (<unknown>, line 3)"
  }
}