{
  "task_name": "boggle_solver",
  "model": "phi3:14b",
  "timestamp": "2026-02-20T17:02:22.931867",
  "nl_problem": "# Task: boggle_solver\n# Interface:\nClass: Solution\nMethod: findWords(self, arg1, arg2)\n\nGiven an m x n board of characters and a list of strings words, return all words on the board.\nEach word must be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.\n\nConstraints:\n- m == board.length\n- n == board[i].length\n- 1 <= m, n <= 12\n- 1 <= words.length <= 3 * 10^4\n- 1 <= words[i].length <= 10\n- board and words consist of lowercase English letters.\n- All strings in words are unique.",
  "lisp_spec": "(task\n  (name \"findWords\")\n  (signature ( (board (list (list char))) (words list) ) list)\n  (constraints\n    (constraint \"m == board.length\")\n    (constraint \"n == board[i].length\")\n    (constraint \"1 <= m, n <= 12\")\n    (constraint \"1 <= words.length <= 3 * 10^4\")\n    (constraint \"1 <= words[i].length <= 10\")\n    (constraint \"board and words consist of lowercase English letters.\")\n    (constraint \"All strings in words are unique.\")\n  )\n  (goal\n    (description \"Return all words on the board that can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.\")\n    (rule \"Each word must be constructed from letters of sequentially adjacent cells.\")\n    (return \"A list of words found on the board that meet the criteria.\")\n  )\n)",
  "generated_code": "# solution.py\nfrom typing import List, Optional, Dict, Set, Any\nimport heapq\nimport collections\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_word = False\n        self.words_under = set()\n\nclass Solution:\n    class Trie:\n        def __init__(self):\n            self.root = TrieNode()\n        \n        def insert(self, word: str) -> None:\n            node = self.root\n            for char in word:\n                if char not in node.children:\n                    node.children[char] = TrieNode()\n                node = node.children[char]\n            node.is_word = True\n        \n        def search(self, prefix: str) -> Optional[TrieNode]:\n            node = self.root\n            for char in prefix:\n                if char not in node.children:\n                    return None\n                node = node.children[char]\n            return node\n    \n    class SolutionHelper:\n        def __init__(self, board: List[List[str]], trie: 'Trie'):\n            self.board = board\n            self.trie = trie\n            self.m = len(board)\n            self.n = len(board[0]) if self.m > 0 else 0\n            self.visited = [[False] * self.n for _ in range(self.m)]\n        \n        def dfs(self, i: int, j: int, node: TrieNode) -> None:\n            if not (0 <= i < self.m and \n                    0 <= j < self.n and \n                    not self.visited[i][j]):\n                return\n            \n            char = board[i][j]\n            node = node.children.get(char)\n            if node is None:\n                return\n            \n            self.visited[i][j] = True\n            if node.is_word:\n                self.trie.words_under.add(node.words_under)\n                \n            for di, dj in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                self.dfs(i + di, j + dj, node)\n            \n            self.visited[i][j] = False\n        \n        def findWords(self) -> List[str]:\n            words_found = []\n            for i in range(self.m):\n                for j in range(self.n):\n                    self.dfs(i, j, self.trie.root)\n            \n            return list(self.trie.words_under)\n    \n        def findWordsHelper(self) -> List[str]:\n            trie = Solution.Trie()\n            for word in words:\n                trie.insert(word)\n                \n            helper = self.__class__.SolutionHelper(board, trie)\n            return helper.findWords()\n    \n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\n        return self.__class__.SolutionHelper.findWordsHelper(board, words)",
  "test_passed": false,
  "test_output": "============================= test session starts ==============================\nplatform darwin -- Python 3.14.3, pytest-9.0.2, pluggy-1.6.0\nrootdir: /private/test/llm_complexity_benchmark\nplugins: anyio-4.12.1\ncollected 3 items\n\n01_TestDefinitions/boggle_solver/test_solution.py FFF                    [100%]\n\n=================================== FAILURES ===================================\n______________________________ test_boggle_basic _______________________________\n\n    def test_boggle_basic():\n        solution = Solution()\n        board = [[\"o\",\"a\",\"a\",\"n\"],[\"e\",\"t\",\"a\",\"e\"],[\"i\",\"h\",\"k\",\"r\"],[\"i\",\"f\",\"l\",\"v\"]]\n        words = [\"oath\",\"pea\",\"eat\",\"rain\"]\n>       result = solution.findWords(board, words)\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n01_TestDefinitions/boggle_solver/test_solution.py:8: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <solution.Solution object at 0x1024b30e0>\nboard = [['o', 'a', 'a', 'n'], ['e', 't', 'a', 'e'], ['i', 'h', 'k', 'r'], ['i', 'f', 'l', 'v']]\nwords = ['oath', 'pea', 'eat', 'rain']\n\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\n>       return self.__class__.SolutionHelper.findWordsHelper(board, words)\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nE       TypeError: Solution.SolutionHelper.findWordsHelper() takes 1 positional argument but 2 were given\n\n01_TestDefinitions/boggle_solver/solution.py:78: TypeError\n_______________________________ test_boggle_none _______________________________\n\n    def test_boggle_none():\n        solution = Solution()\n        board = [[\"a\",\"b\"],[\"c\",\"d\"]]\n        words = [\"abcd\"]\n>       assert solution.findWords(board, words) == []\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n01_TestDefinitions/boggle_solver/test_solution.py:15: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <solution.Solution object at 0x10251d310>\nboard = [['a', 'b'], ['c', 'd']], words = ['abcd']\n\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\n>       return self.__class__.SolutionHelper.findWordsHelper(board, words)\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nE       TypeError: Solution.SolutionHelper.findWordsHelper() takes 1 positional argument but 2 were given\n\n01_TestDefinitions/boggle_solver/solution.py:78: TypeError\n_____________________________ test_boggle_overlap ______________________________\n\n    def test_boggle_overlap():\n        solution = Solution()\n        board = [[\"a\",\"b\"],[\"a\",\"a\"]]\n        words = [\"aba\",\"baa\",\"aaa\",\"ab\"]\n>       result = solution.findWords(board, words)\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n01_TestDefinitions/boggle_solver/test_solution.py:21: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <solution.Solution object at 0x10251e210>\nboard = [['a', 'b'], ['a', 'a']], words = ['aba', 'baa', 'aaa', 'ab']\n\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\n>       return self.__class__.SolutionHelper.findWordsHelper(board, words)\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nE       TypeError: Solution.SolutionHelper.findWordsHelper() takes 1 positional argument but 2 were given\n\n01_TestDefinitions/boggle_solver/solution.py:78: TypeError\n=========================== short test summary info ============================\nFAILED 01_TestDefinitions/boggle_solver/test_solution.py::test_boggle_basic\nFAILED 01_TestDefinitions/boggle_solver/test_solution.py::test_boggle_none - ...\nFAILED 01_TestDefinitions/boggle_solver/test_solution.py::test_boggle_overlap\n============================== 3 failed in 0.03s ===============================\n",
  "test_errors": "",
  "complexity_metrics": {
    "total_complexity_score": 0.3429,
    "python": {
      "cyclomatic_avg": 1.0,
      "cyclomatic_max": 1,
      "wmc": 2,
      "maintainability_index": 52.055385686853626,
      "max_nesting_depth": 5,
      "halstead_volume": 0,
      "lloc": 60,
      "loc": 78
    },
    "lisp": {
      "lisp_max_depth": 6,
      "lisp_constraints": 8,
      "lisp_rules": 1,
      "lisp_token_count": 127
    }
  }
}