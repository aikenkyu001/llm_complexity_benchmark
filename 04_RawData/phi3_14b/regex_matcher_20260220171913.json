{
  "task_name": "regex_matcher",
  "model": "phi3:14b",
  "timestamp": "2026-02-20T17:19:13.886936",
  "nl_problem": "# Task: regex_matcher\n# Interface:\nClass: Solution\nMethod: isMatch(self, arg1, arg2)\n\nGiven an input string s and a pattern p, implement regular expression matching with support for '.' and '*' where:\n- '.' Matches any single character.\u200b\u200b\u200b\u200b\n- '*' Matches zero or more of the preceding element.\nThe matching should cover the entire input string (not partial).\n\nConstraints:\n- 1 <= s.length <= 20\n- 1 <= p.length <= 20\n- s contains only lowercase English letters.\n- p contains only lowercase English letters, '.', and '*'.\n- It is guaranteed for each appearance of the character '*', there will be a previous valid character to match.",
  "lisp_spec": "(task\n  (name \"isMatch\")\n  (signature ( (s string) (p string) ) bool)\n  (constraints\n    (constraint \"1 <= s.length <= 20\")\n    (constraint \"1 <= p.length <= 20\")\n    (constraint \"s contains only lowercase English letters.\")\n    (constraint \"p contains only lowercase English letters, '.' and '*'.\")\n    (constraint \"It is guaranteed for each appearance of the character '*', there will be a previous valid character to match.\")\n  )\n  (goal\n    (description \"Implement regular expression matching with support for '.' and '*' where: - '.' Matches any single character. - '*' Matches zero or more of the preceding element. The matching should cover the entire input string (not partial).\")\n    (rule \"The function must return true if there is a match, false otherwise.\")\n    (return \"Returns true if s matches p according to the rules for '.', and '*'. Returns false otherwise.\")\n  )\n)",
  "generated_code": "# solution.py\nfrom typing import List, Optional, Dict, Set, Any\nimport heapq\nimport collections\n\nclass Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        # Implementation of regular expression matching with support for '.' and '*'\n        \n        dp = [[False] * (len(s) + 1) for _ in range(len(p) + 1)]\n        dp[-1][-1] = True\n\n        for i in range(len(p)-2, -1, -1):\n            if p[i] == \"*\":\n                dp[i][len(s)] = dp[i+1][len(n)]\n                \n            for j in range(len(s), 0, -1):\n                dp[i][j] |= dp[i+1][j] or (dp[i+1][j-1] and s[j-1] == p[i])\n        \n        return dp[0][len(s)]",
  "test_passed": false,
  "test_output": "============================= test session starts ==============================\nplatform darwin -- Python 3.14.3, pytest-9.0.2, pluggy-1.6.0\nrootdir: /private/test/llm_complexity_benchmark\nplugins: anyio-4.12.1\ncollected 2 items\n\n01_TestDefinitions/regex_matcher/test_solution.py FF                     [100%]\n\n=================================== FAILURES ===================================\n_______________________________ test_regex_basic _______________________________\n\n    def test_regex_basic():\n        solution = Solution()\n        assert solution.isMatch(\"aa\", \"a\") == False\n>       assert solution.isMatch(\"aa\", \"a*\") == True\nE       AssertionError: assert False == True\nE        +  where False = isMatch('aa', 'a*')\nE        +    where isMatch = <solution.Solution object at 0x1060570e0>.isMatch\n\n01_TestDefinitions/regex_matcher/test_solution.py:7: AssertionError\n______________________________ test_regex_complex ______________________________\n\n    def test_regex_complex():\n        solution = Solution()\n>       assert solution.isMatch(\"aab\", \"c*a*b\") == True\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n01_TestDefinitions/regex_matcher/test_solution.py:12: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <solution.Solution object at 0x1060c1310>, s = 'aab', p = 'c*a*b'\n\n    def isMatch(self, s: str, p: str) -> bool:\n        # Implementation of regular expression matching with support for '.' and '*'\n    \n        dp = [[False] * (len(s) + 1) for _ in range(len(p) + 1)]\n        dp[-1][-1] = True\n    \n        for i in range(len(p)-2, -1, -1):\n            if p[i] == \"*\":\n>               dp[i][len(s)] = dp[i+1][len(n)]\n                                            ^\nE               NameError: name 'n' is not defined\n\n01_TestDefinitions/regex_matcher/solution.py:15: NameError\n=========================== short test summary info ============================\nFAILED 01_TestDefinitions/regex_matcher/test_solution.py::test_regex_basic - ...\nFAILED 01_TestDefinitions/regex_matcher/test_solution.py::test_regex_complex\n============================== 2 failed in 0.03s ===============================\n",
  "test_errors": "",
  "complexity_metrics": {
    "total_complexity_score": 0.35429999999999995,
    "python": {
      "cyclomatic_avg": 7.0,
      "cyclomatic_max": 7,
      "wmc": 7,
      "maintainability_index": 79.10070391883846,
      "max_nesting_depth": 4,
      "halstead_volume": 0,
      "lloc": 13,
      "loc": 20
    },
    "lisp": {
      "lisp_max_depth": 4,
      "lisp_constraints": 6,
      "lisp_rules": 1,
      "lisp_token_count": 134
    }
  }
}