{
  "task_name": "lru_cache",
  "model": "phi3:14b",
  "timestamp": "2026-02-20T17:10:12.570730",
  "nl_problem": "# Task: LRU Cache\n# Interface:\nClass: Solution\nMethod: LRUCache(self, capacity: int) -> 'LRUCache'\n\nDesign a data structure that follows the constraints of a Least Recently Used (LRU) cache.\n\nImplement the LRUCache class:\n- `LRUCache(int capacity)`: Initialize the LRU cache with positive size capacity.\n- `int get(int key)`: Return the value of the key if the key exists, otherwise return -1.\n- `void put(int key, int value)`: Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.\n\nThe functions `get` and `put` must each run in O(1) average time complexity.\nYou must not use the built-in `collections.OrderedDict`. You should use a combination of a hash map and a double linked list to achieve the required time complexity.",
  "lisp_spec": "(task\n  (name \"LRUCache\")\n  (signature ( (capacity int) ) 'LRUCache)\n  (constraints\n    (constraint \"Capacity must be a positive integer.\")\n    (constraint \"get and put methods should run in O(1) average time complexity.\")\n    (constraint \"Do not use the built-in collections.OrderedDict.\")\n    (constraint \"Use a combination of hash map and double linked list to achieve required time complexity.\")\n  )\n  (goal\n    (description \"Design an LRU cache data structure with specified capacity constraints.\")\n    (rule \"The get method should return the value of the key if it exists, otherwise -1.\")\n    (rule \"The put method should update or add a key-value pair to the cache. If exceeding capacity, evict least recently used key.\")\n  )\n)",
  "generated_code": "# solution.py\nfrom typing import List, Optional, Dict, Set, Any\nimport heapq\nimport collections\n\nclass Node:\n    def __init__(self, key: int, value: int):\n        self.key = key\n        self.value = value\n        self.prev = None\n        self.next = None\n\nclass LRUCache:\n    def __init__(self, capacity: int) -> None:\n        if not isinstance(capacity, int) or capacity <= 0:\n            raise ValueError(\"Capacity must be a positive integer.\")\n        \n        self.capacity = capacity\n        self.cache: Dict[int, Node] = {}\n        self.head = None\n        self.tail = None\n    \n    def get(self, key: int) -> Optional[int]:\n        if key not in self.cache:\n            return -1\n        \n        node = self.cache[key]\n        self._remove_node(node)\n        self._add_to_head(node)\n        return node.value\n    \n    def put(self, key: int, value: int) -> None:\n        if key in selfe.cache:\n            node = self.cache[key]\n            node.value = value\n            self._remove_node(node)\n            self._add_to_head(node)\n        else:\n            newNode = Node(key, value)\n            if len(self.cache) >= self.capacity:\n                tail = self.tail\n                del self.cache[tail.key]\n                self._remove_node(tail)\n                \n                if not self.head.next:\n                    self.head = None\n                else:\n                    self.head = node\n            else:\n                self.capacity += 1\n            \n            self._add_to_head(newNode)\n            self.cache[key] = newNode\n    \n    def _remove_node(self, node: Node):\n        if node.prev is not None:\n            node.prev.next = node.next\n        else:\n            self.tail = node.next\n        \n        if node.next is not None:\n            node.next.prev = node.prev\n        else:\n            self.head = node.prev\n    \n    def _add_to_head(self, node: Node):\n        node.prev = None\n        node.next = self.head\n        \n        if self.head is not None:\n            self.head.prev = node\n            \n        self.head = node\n        if self.tail is None:\n            self.tail = node\n    \n    def _get_keys(self) -> List[int]:\n        keys = []\n        current = self.head\n        \n        while current is not None:\n            keys.append(current.key)\n            current = current.next\n            \n        return keys\n\nclass Solution:\n    def LRUCache(self, capacity: int) -> LRUCache:\n        return LRUCache(capacity)",
  "test_passed": false,
  "test_output": "============================= test session starts ==============================\nplatform darwin -- Python 3.14.3, pytest-9.0.2, pluggy-1.6.0\nrootdir: /private/test/llm_complexity_benchmark\nplugins: anyio-4.12.1\ncollected 3 items\n\n01_TestDefinitions/lru_cache/test_solution.py FFF                        [100%]\n\n=================================== FAILURES ===================================\n________________________________ test_lru_basic ________________________________\n\n    def test_lru_basic():\n        lru = Solution().LRUCache(2)\n>       lru.put(1, 1)\n\n01_TestDefinitions/lru_cache/test_solution.py:6: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <solution.LRUCache object at 0x104507230>, key = 1, value = 1\n\n    def put(self, key: int, value: int) -> None:\n>       if key in selfe.cache:\n                  ^^^^^\nE       NameError: name 'selfe' is not defined\n\n01_TestDefinitions/lru_cache/solution.py:33: NameError\n_______________________________ test_lru_update ________________________________\n\n    def test_lru_update():\n        lru = Solution().LRUCache(1)\n>       lru.put(2, 1)\n\n01_TestDefinitions/lru_cache/test_solution.py:18: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <solution.LRUCache object at 0x10456dd10>, key = 2, value = 1\n\n    def put(self, key: int, value: int) -> None:\n>       if key in selfe.cache:\n                  ^^^^^\nE       NameError: name 'selfe' is not defined\n\n01_TestDefinitions/lru_cache/solution.py:33: NameError\n__________________________ test_lru_complex_sequence ___________________________\n\n    def test_lru_complex_sequence():\n        lru = Solution().LRUCache(2)\n>       lru.put(1, 1)\n\n01_TestDefinitions/lru_cache/test_solution.py:27: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <solution.LRUCache object at 0x10456e490>, key = 1, value = 1\n\n    def put(self, key: int, value: int) -> None:\n>       if key in selfe.cache:\n                  ^^^^^\nE       NameError: name 'selfe' is not defined\n\n01_TestDefinitions/lru_cache/solution.py:33: NameError\n=========================== short test summary info ============================\nFAILED 01_TestDefinitions/lru_cache/test_solution.py::test_lru_basic - NameEr...\nFAILED 01_TestDefinitions/lru_cache/test_solution.py::test_lru_update - NameE...\nFAILED 01_TestDefinitions/lru_cache/test_solution.py::test_lru_complex_sequence\n============================== 3 failed in 0.03s ===============================\n",
  "test_errors": "",
  "complexity_metrics": {
    "total_complexity_score": 0.33599999999999997,
    "python": {
      "cyclomatic_avg": 2.375,
      "cyclomatic_max": 4,
      "wmc": 19,
      "maintainability_index": 47.87741965195596,
      "max_nesting_depth": 5,
      "halstead_volume": 0,
      "lloc": 72,
      "loc": 89
    },
    "lisp": {
      "lisp_max_depth": 4,
      "lisp_constraints": 5,
      "lisp_rules": 2,
      "lisp_token_count": 105
    }
  }
}