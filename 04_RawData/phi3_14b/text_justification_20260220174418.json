{
  "task_name": "text_justification",
  "model": "phi3:14b",
  "timestamp": "2026-02-20T17:44:18.023056",
  "nl_problem": "# Task: text_justification\n# Interface:\nClass: Solution\nMethod: fullJustify(self, arg1, arg2)\n\nGiven an array of strings words and a width maxWidth, format the text such that each line has exactly maxWidth characters and is fully (left and right) justified.\nYou should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces ' ' when necessary so that each line has exactly maxWidth characters.\nExtra spaces between words should be distributed as evenly as possible. If the number of spaces on a line does not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.\nFor the last line of text, it should be left-justified, and no extra space is inserted between words.\n\nConstraints:\n- 1 <= words.length <= 300\n- 1 <= words[i].length <= 20\n- words[i] consists of only English letters and symbols.\n- 1 <= maxWidth <= 100\n- words[i].length <= maxWidth",
  "lisp_spec": "(task\n  (name \"fullJustify\")\n  (signature ((words listofstring) (maxWidth int)) (listofstring))\n  (constraints\n    (constraint \"The length of words is between 1 and 300.\")\n    (constraint \"Each word in the array has a length between 1 and 20.\")\n    (constraint \"Words consist only of English letters and symbols.\")\n    (constraint \"maxWidth is between 1 and 100, inclusive.\")\n    (constraint \"The length of each word does not exceed maxWidth.\")\n  )\n  (goal\n    (description \"Format the text such that each line has exactly maxWidth characters and is fully justified. Pack words in a greedy approach; pack as many words as possible on each line, padding extra spaces ' ' when necessary so that each line has exactly maxWidth characters.\")\n    (rule \"Extra spaces between words should be distributed evenly as much as possible. If the number of spaces on a line does not divide evenly between words, assign more spaces to empty slots on the left than on the right.\")\n    (return \"A list of strings representing each line of justified text.\"))",
  "generated_code": "from typing import List\nimport math\n\nclass Solution:\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\n        if not words or len(words) == 0:\n            return []\n        \n        # Initialize the result list and a variable to keep track of current line length.\n        lines = []\n        curr_line, curr_length = [], 0\n        for word in words:\n            # If adding this word would exceed maxWidth, justify the current line and start a new one.\n            if len(word) + len(curr_line) + (1 if curr_line else 0) > maxWidth:\n                self._justifyLine(lines, curr_length, curr_line, maxWidth)\n                curr_line = [word]\n                curr_length = len(word)\n            else:\n                curr_line.append(word)\n                curr_length += len(word) + 1 # Add one for the space after word if not last word in line\n        \n        # Justify and add the final line to lines list.\n        self._justifyLine(lines, curr_length, curr_ean, maxWidth)\n        return lines\n    \n    def _justifyLine(self, lines: List[str], curr_length: int, words: List[str], maxWidth: int):\n        if not words or len(words) == 0:\n            return\n        \n        # Calculate the number of spaces needed to justify this line.\n        num_spaces = maxWidth - curr_length + (1 if lines[-1] else 0)\n        if len(lines) > 1 and len(words) > 1:\n            # Distribute extra spaces evenly across all but the last space in the line, then add one to the leftmost slots.\n            num_gaps = len(words) - 1\n            base_spaces = num_spaces // num_gaps\n            extras = num_spaces % num_gaps\n            \n            for i in range(num_gaps):\n                words[i] += ' ' * (base_spaces + int(i < extras))\n                \n        # Add the justified line to lines list.\n        lines.append(' '.join(words))\n        \n    def _justifyLine(self, lines: List[str], curr_length: int, words: List[str], maxWidth: int):\n        if not words or len(lines) == 0:\n            return\n            \n        # Calculate the number of spaces needed to justify this line.\n        num_spaces = maxWidth - curr_length + (1 if lines[-1] else 0)\n        \n        # Distribute extra spaces evenly across all but the last space in the line, then add one to the leftmost slots.\n        num_gaps = len(words) - 1\n        base_spaces = num_spaces // num_gaps\n        extras = num_spaces % num_gaps\n        \n        for i in range(num_gaps):\n            words[i] += ' ' * (base_spaces + int(i < extras))\n            \n        # Add the justified line to lines list.\n        lines.append(' '.join(words))",
  "test_passed": false,
  "test_output": "============================= test session starts ==============================\nplatform darwin -- Python 3.14.3, pytest-9.0.2, pluggy-1.6.0\nrootdir: /private/test/llm_complexity_benchmark\nplugins: anyio-4.12.1\ncollected 2 items\n\n01_TestDefinitions/text_justification/test_solution.py FF                [100%]\n\n=================================== FAILURES ===================================\n________________________ test_text_justification_basic _________________________\n\n    def test_text_justification_basic():\n        solution = Solution()\n        words = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"]\n        maxWidth = 16\n        expected = [\n           \"This    is    an\",\n           \"example  of text\",\n           \"justification.  \"\n        ]\n>       assert solution.fullJustify(words, maxWidth) == expected\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n01_TestDefinitions/text_justification/test_solution.py:13: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <solution.Solution object at 0x1043830e0>\nwords = ['This', 'is', 'an', 'example', 'of', 'text', ...], maxWidth = 16\n\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\n        if not words or len(words) == 0:\n            return []\n    \n        # Initialize the result list and a variable to keep track of current line length.\n        lines = []\n        curr_line, curr_length = [], 0\n        for word in words:\n            # If adding this word would exceed maxWidth, justify the current line and start a new one.\n            if len(word) + len(curr_line) + (1 if curr_line else 0) > maxWidth:\n                self._justifyLine(lines, curr_length, curr_line, maxWidth)\n                curr_line = [word]\n                curr_length = len(word)\n            else:\n                curr_line.append(word)\n                curr_length += len(word) + 1 # Add one for the space after word if not last word in line\n    \n        # Justify and add the final line to lines list.\n>       self._justifyLine(lines, curr_length, curr_ean, maxWidth)\n                                              ^^^^^^^^\nE       NameError: name 'curr_ean' is not defined\n\n01_TestDefinitions/text_justification/solution.py:23: NameError\n_______________________ test_text_justification_complex ________________________\n\n    def test_text_justification_complex():\n        solution = Solution()\n        words = [\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"]\n        maxWidth = 16\n        expected = [\n          \"What   must   be\",\n          \"acknowledgment  \",\n          \"shall be        \"\n        ]\n>       assert solution.fullJustify(words, maxWidth) == expected\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n01_TestDefinitions/text_justification/test_solution.py:24: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <solution.Solution object at 0x1043ed310>\nwords = ['What', 'must', 'be', 'acknowledgment', 'shall', 'be'], maxWidth = 16\n\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\n        if not words or len(words) == 0:\n            return []\n    \n        # Initialize the result list and a variable to keep track of current line length.\n        lines = []\n        curr_line, curr_length = [], 0\n        for word in words:\n            # If adding this word would exceed maxWidth, justify the current line and start a new one.\n            if len(word) + len(curr_line) + (1 if curr_line else 0) > maxWidth:\n                self._justifyLine(lines, curr_length, curr_line, maxWidth)\n                curr_line = [word]\n                curr_length = len(word)\n            else:\n                curr_line.append(word)\n                curr_length += len(word) + 1 # Add one for the space after word if not last word in line\n    \n        # Justify and add the final line to lines list.\n>       self._justifyLine(lines, curr_length, curr_ean, maxWidth)\n                                              ^^^^^^^^\nE       NameError: name 'curr_ean' is not defined\n\n01_TestDefinitions/text_justification/solution.py:23: NameError\n=========================== short test summary info ============================\nFAILED 01_TestDefinitions/text_justification/test_solution.py::test_text_justification_basic\nFAILED 01_TestDefinitions/text_justification/test_solution.py::test_text_justification_complex\n============================== 2 failed in 0.03s ===============================\n",
  "test_errors": "",
  "complexity_metrics": {
    "total_complexity_score": 0.35929999999999995,
    "python": {
      "cyclomatic_avg": 6.0,
      "cyclomatic_max": 7,
      "wmc": 18,
      "maintainability_index": 68.48263404840428,
      "max_nesting_depth": 4,
      "halstead_volume": 0,
      "lloc": 39,
      "loc": 60
    },
    "lisp": {
      "lisp_max_depth": 4,
      "lisp_constraints": 6,
      "lisp_rules": 1,
      "lisp_token_count": 159
    }
  }
}