{
  "task_name": "boggle_solver",
  "model": "llama3.2-vision:11b",
  "timestamp": "2026-02-20T16:15:57.983964",
  "nl_problem": "# Task: boggle_solver\n# Interface:\nClass: Solution\nMethod: findWords(self, arg1, arg2)\n\nGiven an m x n board of characters and a list of strings words, return all words on the board.\nEach word must be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.\n\nConstraints:\n- m == board.length\n- n == board[i].length\n- 1 <= m, n <= 12\n- 1 <= words.length <= 3 * 10^4\n- 1 <= words[i].length <= 10\n- board and words consist of lowercase English letters.\n- All strings in words are unique.",
  "lisp_spec": "(task\n  (name \"boggle_solver\")\n  (signature\n    ( (board (list (list char))) (words (list (list char))) )\n    (list (list char)))\n  (constraints\n    (constraint \"m == board.length\")\n    (constraint \"n == board[i].length\")\n    (constraint \"1 <= m, n <= 12\")\n    (constraint \"1 <= words.length <= 3 * 10^4\")\n    (constraint \"1 <= words[i].length <= 10\")\n    (constraint \"board and words consist of lowercase English letters\")\n    (constraint \"All strings in words are unique\")\n  )\n  (goal\n    (description \"Return all words on the board.\")\n    (rule \"Each word must be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring.\")\n    (rule \"The same letter cell may not be used more than once in a word.\")\n    (return \"A list of all words on the board.\")\n  )\n)",
  "generated_code": "from typing import List, Set\n\nclass Solution:\n    def boggle_solver(self, board: List[List[str]], words: List[str]) -> List[str]:\n        # Create a set of words for efficient lookups\n        word_set = set(words)\n        \n        # Create a dictionary to store the words found\n        found_words = collections.defaultdict(int)\n        \n        # Define the directions for adjacent cells\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        \n        # Define the rows and columns of the board\n        rows, cols = len(board), len(board[0])\n        \n        # Create a set to store the visited cells\n        visited = set()\n        \n        # Define a helper function to perform DFS\n        def dfs(r: int, c: int, word: str) -> None:\n            # If the current word is in the word set, increment its count\n            if word in word_set:\n                found_words[word] += 1\n            \n            # If the current word is not in the word set, return\n            if word not in word_set:\n                return\n            \n            # Mark the current cell as visited\n            visited.add((r, c))\n            \n            # Explore the adjacent cells\n            for dr, dc in directions:\n                nr, nc = r + dr, c + dc\n                \n                # If the adjacent cell is within the board and not visited\n                if 0 <= nr < rows and 0 <= nc < cols and (nr, nc) not in visited:\n                    # Recursively explore the adjacent cell\n                    dfs(nr, nc, word + board[nr][nc])\n            \n            # Unmark the current cell as visited\n            visited.remove((r, c))\n        \n        # Explore each cell in the board\n        for r in range(rows):\n            for c in range(cols):\n                # Start a new DFS from each cell\n                dfs(r, c, board[r][c])\n        \n        # Return the words found\n        return [word for word, count in found_words.items() if count > 0]",
  "test_passed": false,
  "test_output": "============================= test session starts ==============================\nplatform darwin -- Python 3.14.3, pytest-9.0.2, pluggy-1.6.0\nrootdir: /private/test/llm_complexity_benchmark\nplugins: anyio-4.12.1\ncollected 3 items\n\n01_TestDefinitions/boggle_solver/test_solution.py FFF                    [100%]\n\n=================================== FAILURES ===================================\n______________________________ test_boggle_basic _______________________________\n\n    def test_boggle_basic():\n        solution = Solution()\n        board = [[\"o\",\"a\",\"a\",\"n\"],[\"e\",\"t\",\"a\",\"e\"],[\"i\",\"h\",\"k\",\"r\"],[\"i\",\"f\",\"l\",\"v\"]]\n        words = [\"oath\",\"pea\",\"eat\",\"rain\"]\n>       result = solution.findWords(board, words)\n                 ^^^^^^^^^^^^^^^^^^\nE       AttributeError: 'Solution' object has no attribute 'findWords'\n\n01_TestDefinitions/boggle_solver/test_solution.py:8: AttributeError\n_______________________________ test_boggle_none _______________________________\n\n    def test_boggle_none():\n        solution = Solution()\n        board = [[\"a\",\"b\"],[\"c\",\"d\"]]\n        words = [\"abcd\"]\n>       assert solution.findWords(board, words) == []\n               ^^^^^^^^^^^^^^^^^^\nE       AttributeError: 'Solution' object has no attribute 'findWords'\n\n01_TestDefinitions/boggle_solver/test_solution.py:15: AttributeError\n_____________________________ test_boggle_overlap ______________________________\n\n    def test_boggle_overlap():\n        solution = Solution()\n        board = [[\"a\",\"b\"],[\"a\",\"a\"]]\n        words = [\"aba\",\"baa\",\"aaa\",\"ab\"]\n>       result = solution.findWords(board, words)\n                 ^^^^^^^^^^^^^^^^^^\nE       AttributeError: 'Solution' object has no attribute 'findWords'\n\n01_TestDefinitions/boggle_solver/test_solution.py:21: AttributeError\n=========================== short test summary info ============================\nFAILED 01_TestDefinitions/boggle_solver/test_solution.py::test_boggle_basic\nFAILED 01_TestDefinitions/boggle_solver/test_solution.py::test_boggle_none - ...\nFAILED 01_TestDefinitions/boggle_solver/test_solution.py::test_boggle_overlap\n============================== 3 failed in 0.03s ===============================\n",
  "test_errors": "",
  "complexity_metrics": {
    "total_complexity_score": 0.4111,
    "python": {
      "cyclomatic_avg": 5.0,
      "cyclomatic_max": 5,
      "wmc": 5,
      "maintainability_index": 82.16339296202041,
      "max_nesting_depth": 5,
      "halstead_volume": 0,
      "lloc": 23,
      "loc": 52
    },
    "lisp": {
      "lisp_max_depth": 6,
      "lisp_constraints": 8,
      "lisp_rules": 2,
      "lisp_token_count": 118
    }
  }
}