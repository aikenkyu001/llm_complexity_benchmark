{
  "task_name": "lru_cache",
  "model": "gemma3:12b",
  "timestamp": "2026-02-20T15:28:52.202938",
  "nl_problem": "# Task: LRU Cache\n# Interface:\nClass: Solution\nMethod: LRUCache(self, capacity: int) -> 'LRUCache'\n\nDesign a data structure that follows the constraints of a Least Recently Used (LRU) cache.\n\nImplement the LRUCache class:\n- `LRUCache(int capacity)`: Initialize the LRU cache with positive size capacity.\n- `int get(int key)`: Return the value of the key if the key exists, otherwise return -1.\n- `void put(int key, int value)`: Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.\n\nThe functions `get` and `put` must each run in O(1) average time complexity.\nYou must not use the built-in `collections.OrderedDict`. You should use a combination of a hash map and a double linked list to achieve the required time complexity.",
  "lisp_spec": "(task\n  (name \"LRUCache\")\n  (signature ( (capacity int) ) 'LRUCache)\n)\n(constraints\n  (constraint \"The capacity must be a positive integer.\")\n  (constraint \"The get operation must return -1 if the key is not found.\")\n  (constraint \"The get and put operations must each run in O(1) average time complexity.\")\n  (constraint \"The built-in collections.OrderedDict is not allowed.\")\n)\n(goal\n  (description \"Implement a Least Recently Used (LRU) cache data structure.\")\n  (rule \"The cache should maintain a fixed capacity.\")\n  (rule \"When a key is accessed (either through get or put), it should be marked as recently used.\")\n  (rule \"When the cache is full and a new key-value pair needs to be added, the least recently used key should be evicted.\")\n  (return \"The return value is an instance of the LRUCache class, which encapsulates the cache data structure and its associated methods (get and put).\")\n)",
  "generated_code": "from typing import List, Optional, Dict, Set, Any\nimport heapq\nimport collections\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache: Dict[int, int] = {}\n        self.usage: collections.deque = collections.deque()\n\n    def get(self, key: int) -> int:\n        if key in self.cache:\n            self.usage.remove(key)\n            self.usage.append(key)\n            return self.cache[key]\n        else:\n            return -1\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            self.usage.remove(key)\n        elif len(self.cache) >= self.capacity:\n            lru_key = self.usage.popleft()\n            del self.cache[lru_key]\n\n        self.cache[key] = value\n        self.usage.append(key)\n\n\nclass Solution:\n    def LRUCache(self, capacity: int) -> LRUCache:\n        return LRUCache(capacity)",
  "test_passed": true,
  "test_output": "============================= test session starts ==============================\nplatform darwin -- Python 3.14.3, pytest-9.0.2, pluggy-1.6.0\nrootdir: /private/test/llm_complexity_benchmark\nplugins: anyio-4.12.1\ncollected 3 items\n\n01_TestDefinitions/lru_cache/test_solution.py ...                        [100%]\n\n============================== 3 passed in 0.02s ===============================\n",
  "test_errors": "",
  "complexity_metrics": {
    "total_complexity_score": 0.32530000000000003,
    "python": {
      "cyclomatic_avg": 1.75,
      "cyclomatic_max": 3,
      "wmc": 7,
      "maintainability_index": 56.41309685046557,
      "max_nesting_depth": 4,
      "halstead_volume": 0,
      "lloc": 28,
      "loc": 32
    },
    "lisp": {
      "lisp_max_depth": 4,
      "lisp_constraints": 5,
      "lisp_rules": 3,
      "lisp_token_count": 139
    }
  }
}