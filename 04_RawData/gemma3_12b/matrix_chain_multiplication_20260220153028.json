{
  "task_name": "matrix_chain_multiplication",
  "model": "gemma3:12b",
  "timestamp": "2026-02-20T15:30:28.240760",
  "nl_problem": "# Task: matrix_chain_multiplication\n# Interface:\nClass: Solution\nMethod: matrixChainOrder(self, arg1)\n\nGiven a list of matrix dimensions, find the minimum number of scalar multiplications needed to multiply the sequence of matrices.\nIf the sequence of matrices is A1, A2, ..., An, where Ai has dimensions `p[i-1] x p[i]`, the input is the list `p = [p0, p1, ..., pn]`.\n\nConstraints:\n- 2 <= p.length <= 100\n- 1 <= p[i] <= 100",
  "lisp_spec": "(task\n  (name \"matrixChainOrder\")\n  (signature ( (p (list int)) ) int)\n  (constraints\n    (constraint \"The input list 'p' must have a length between 2 and 100, inclusive.\")\n    (constraint \"Each element in the list 'p' must be an integer between 1 and 100, inclusive.\")\n  )\n  (goal\n    (description \"Calculate the minimum number of scalar multiplications needed to multiply a chain of matrices.\")\n    (rule \"The input list 'p' represents the dimensions of the matrices.  The i-th matrix Ai has dimensions p[i-1] x p[i].\")\n    (rule \"The goal is to find the minimum number of scalar multiplications required to compute the product A1 * A2 * ... * An.\")\n    (return \"Return the minimum number of scalar multiplications as an integer.  If the input list 'p' is invalid (e.g., length outside the allowed range or invalid dimensions), the behavior is undefined.\")\n  )\n)",
  "generated_code": "from typing import List, Optional, Dict, Set, Any\nimport heapq\nimport collections\n\nclass Solution:\n    def matrixChainOrder(self, p: List[int]) -> int:\n        \"\"\"\n        Calculates the minimum number of scalar multiplications needed to multiply a chain of matrices.\n\n        Args:\n            p: A list of integers representing the dimensions of the matrices.\n               The i-th matrix Ai has dimensions p[i-1] x p[i].\n\n        Returns:\n            The minimum number of scalar multiplications as an integer.\n        \"\"\"\n        n = len(p) - 1\n        m = [[0] * (n + 1) for _ in range(n + 1)]\n\n        for length in range(2, n + 1):\n            for i in range(1, n - length + 2):\n                j = i + length - 1\n                m[i][j] = float('inf')\n                for k in range(i, j):\n                    cost = m[i][k] + m[k + 1][j] + p[i - 1] * p[k] * p[j]\n                    m[i][j] = min(m[i][j], cost)\n\n        return m[1][n]",
  "test_passed": true,
  "test_output": "============================= test session starts ==============================\nplatform darwin -- Python 3.14.3, pytest-9.0.2, pluggy-1.6.0\nrootdir: /private/test/llm_complexity_benchmark\nplugins: anyio-4.12.1\ncollected 2 items\n\n01_TestDefinitions/matrix_chain_multiplication/test_solution.py ..       [100%]\n\n============================== 2 passed in 0.02s ===============================\n",
  "test_errors": "",
  "complexity_metrics": {
    "total_complexity_score": 0.3145,
    "python": {
      "cyclomatic_avg": 5.0,
      "cyclomatic_max": 5,
      "wmc": 5,
      "maintainability_index": 85.99560779370897,
      "max_nesting_depth": 5,
      "halstead_volume": 0,
      "lloc": 16,
      "loc": 28
    },
    "lisp": {
      "lisp_max_depth": 5,
      "lisp_constraints": 3,
      "lisp_rules": 2,
      "lisp_token_count": 135
    }
  }
}