{
  "task_name": "boggle_solver",
  "model": "gemma3:12b",
  "timestamp": "2026-02-20T15:22:29.941535",
  "nl_problem": "# Task: boggle_solver\n# Interface:\nClass: Solution\nMethod: findWords(self, arg1, arg2)\n\nGiven an m x n board of characters and a list of strings words, return all words on the board.\nEach word must be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.\n\nConstraints:\n- m == board.length\n- n == board[i].length\n- 1 <= m, n <= 12\n- 1 <= words.length <= 3 * 10^4\n- 1 <= words[i].length <= 10\n- board and words consist of lowercase English letters.\n- All strings in words are unique.",
  "lisp_spec": "(task\n  (name \"findWords\")\n  (signature ( (board (list (list char))) (words (list string)) ) (list string))\n  (constraints\n    (constraint \"m == board.length\")\n    (constraint \"n == board[i].length\")\n    (constraint \"1 <= m, n <= 12\")\n    (constraint \"1 <= words.length <= 3 * 10^4\")\n    (constraint \"1 <= words[i].length <= 10\")\n    (constraint \"board and words consist of lowercase English letters.\")\n    (constraint \"All strings in words are unique.\")\n  )\n  (goal\n    (description \"Find all words from the given list that can be formed by traversing adjacent cells (horizontally or vertically) on the board, without reusing the same cell more than once.\")\n    (rule \"A word is valid if it exists in the 'words' list and can be formed by traversing adjacent cells on the board.\")\n    (rule \"Adjacent cells are horizontally or vertically neighboring.\")\n    (rule \"The same letter cell may not be used more than once in a word.\")\n    (return \"Return a list of strings representing the valid words found on the board. The order of words in the returned list does not matter.\")\n  )\n)",
  "generated_code": "from typing import List, Optional, Dict, Set, Any\nimport heapq\nimport collections\n\nclass Solution:\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\n        \"\"\"\n        Finds all words from the given list that can be formed by traversing adjacent cells\n        (horizontally or vertically) on the board, without reusing the same cell more than once.\n\n        Args:\n            board: A 2D list of characters representing the board.\n            words: A list of strings representing the words to search for.\n\n        Returns:\n            A list of strings representing the valid words found on the board.\n        \"\"\"\n\n        rows, cols = len(board), len(board[0])\n        trie = {}\n\n        # Build Trie\n        for word in words:\n            node = trie\n            for char in word:\n                if char not in node:\n                    node[char] = {}\n                    node = node[char]\n                else:\n                    node = node[char]\n            node['#'] = word\n\n        result = set()\n\n        def dfs(row, col, node):\n            if '#' in node:\n                result.add(node['#'])\n\n            if row < 0 or row >= rows or col < 0 or col >= cols or board[row][col] not in node:\n                return\n\n            char = board[row][col]\n            board[row][col] = '#'  # Mark as visited\n            \n            dfs(row + 1, col, node[char])\n            dfs(row - 1, col, node[char])\n            dfs(row, col + 1, node[char])\n            dfs(row, col - 1, node[char])\n\n            board[row][col] = char  # Backtrack\n\n        for row in range(rows):\n            for col in range(cols):\n                dfs(row, col, trie)\n\n        return list(result)",
  "test_passed": false,
  "test_output": "============================= test session starts ==============================\nplatform darwin -- Python 3.14.3, pytest-9.0.2, pluggy-1.6.0\nrootdir: /private/test/llm_complexity_benchmark\nplugins: anyio-4.12.1\ncollected 3 items\n\n01_TestDefinitions/boggle_solver/test_solution.py F.F                    [100%]\n\n=================================== FAILURES ===================================\n______________________________ test_boggle_basic _______________________________\n\n    def test_boggle_basic():\n        solution = Solution()\n        board = [[\"o\",\"a\",\"a\",\"n\"],[\"e\",\"t\",\"a\",\"e\"],[\"i\",\"h\",\"k\",\"r\"],[\"i\",\"f\",\"l\",\"v\"]]\n        words = [\"oath\",\"pea\",\"eat\",\"rain\"]\n>       result = solution.findWords(board, words)\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n01_TestDefinitions/boggle_solver/test_solution.py:8: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n01_TestDefinitions/boggle_solver/solution.py:54: in findWords\n    dfs(row, col, trie)\n01_TestDefinitions/boggle_solver/solution.py:47: in dfs\n    dfs(row, col + 1, node[char])\n01_TestDefinitions/boggle_solver/solution.py:45: in dfs\n    dfs(row + 1, col, node[char])\n01_TestDefinitions/boggle_solver/solution.py:45: in dfs\n    dfs(row + 1, col, node[char])\n01_TestDefinitions/boggle_solver/solution.py:46: in dfs\n    dfs(row - 1, col, node[char])\n01_TestDefinitions/boggle_solver/solution.py:47: in dfs\n    dfs(row, col + 1, node[char])\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nrow = 1, col = 2, node = 'oath'\n\n    def dfs(row, col, node):\n        if '#' in node:\n            result.add(node['#'])\n    \n        if row < 0 or row >= rows or col < 0 or col >= cols or board[row][col] not in node:\n            return\n    \n        char = board[row][col]\n        board[row][col] = '#'  # Mark as visited\n    \n>       dfs(row + 1, col, node[char])\n                          ^^^^^^^^^^\nE       TypeError: string indices must be integers, not 'str'\n\n01_TestDefinitions/boggle_solver/solution.py:45: TypeError\n_____________________________ test_boggle_overlap ______________________________\n\n    def test_boggle_overlap():\n        solution = Solution()\n        board = [[\"a\",\"b\"],[\"a\",\"a\"]]\n        words = [\"aba\",\"baa\",\"aaa\",\"ab\"]\n>       result = solution.findWords(board, words)\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n01_TestDefinitions/boggle_solver/test_solution.py:21: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n01_TestDefinitions/boggle_solver/solution.py:54: in findWords\n    dfs(row, col, trie)\n01_TestDefinitions/boggle_solver/solution.py:47: in dfs\n    dfs(row, col + 1, node[char])\n01_TestDefinitions/boggle_solver/solution.py:48: in dfs\n    dfs(row, col - 1, node[char])\n01_TestDefinitions/boggle_solver/solution.py:45: in dfs\n    dfs(row + 1, col, node[char])\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nrow = 1, col = 0, node = 'ab'\n\n    def dfs(row, col, node):\n        if '#' in node:\n            result.add(node['#'])\n    \n        if row < 0 or row >= rows or col < 0 or col >= cols or board[row][col] not in node:\n            return\n    \n        char = board[row][col]\n        board[row][col] = '#'  # Mark as visited\n    \n>       dfs(row + 1, col, node[char])\n                          ^^^^^^^^^^\nE       TypeError: string indices must be integers, not 'str'\n\n01_TestDefinitions/boggle_solver/solution.py:45: TypeError\n=========================== short test summary info ============================\nFAILED 01_TestDefinitions/boggle_solver/test_solution.py::test_boggle_basic\nFAILED 01_TestDefinitions/boggle_solver/test_solution.py::test_boggle_overlap\n========================= 2 failed, 1 passed in 0.03s ==========================\n",
  "test_errors": "",
  "complexity_metrics": {
    "total_complexity_score": 0.4532,
    "python": {
      "cyclomatic_avg": 6.0,
      "cyclomatic_max": 6,
      "wmc": 6,
      "maintainability_index": 77.66408610651852,
      "max_nesting_depth": 5,
      "halstead_volume": 0,
      "lloc": 34,
      "loc": 56
    },
    "lisp": {
      "lisp_max_depth": 6,
      "lisp_constraints": 8,
      "lisp_rules": 3,
      "lisp_token_count": 166
    }
  }
}