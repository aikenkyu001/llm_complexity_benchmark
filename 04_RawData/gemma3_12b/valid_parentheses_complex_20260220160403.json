{
  "task_name": "valid_parentheses_complex",
  "model": "gemma3:12b",
  "timestamp": "2026-02-20T16:04:03.674957",
  "nl_problem": "# Task: valid_parentheses_complex\n# Interface:\nClass: Solution\nMethod: isValid(self, arg1)\n\nGiven a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\nAn input string is valid if:\n1. Open brackets must be closed by the same type of brackets.\n2. Open brackets must be closed in the correct order.\n3. Every close bracket has a corresponding open bracket of the same type.\nInclude support for nested and complex structures.\n\nConstraints:\n- 1 <= s.length <= 10^4\n- s consists of parentheses only '()[]{}'.",
  "lisp_spec": "(task\n  (name \"isValid\")\n  (signature ( (arg1 string) ) boolean)\n  (constraints\n    (constraint \"The input string contains only '(', ')', '{', '}', '[' and ']'.\")\n    (constraint \"The length of the input string is between 1 and 10000.\")\n  )\n  (goal\n    (description \"Determine if the input string containing parentheses is valid.\")\n    (rule \"The string is valid if all opening brackets have corresponding closing brackets of the same type in the correct order.\")\n    (return \"Return `true` if the input string is valid, `false` otherwise.\")\n  )\n)",
  "generated_code": "from typing import List, Optional, Dict, Set, Any\nimport heapq\nimport collections\n\nclass Solution:\n    def isValid(self, arg1: str) -> bool:\n        \"\"\"\n        Determine if the input string containing parentheses is valid.\n\n        The string is valid if all opening brackets have corresponding closing brackets of the same type in the correct order.\n\n        Args:\n            arg1 (str): The input string containing parentheses.\n\n        Returns:\n            bool: True if the input string is valid, False otherwise.\n        \"\"\"\n        stack = []\n        mapping = {\")\": \"(\", \"}\": \"{\", \"]\": \"[\"}\n\n        for char in arg1:\n            if char in mapping:\n                top_element = stack.pop() if stack else '#'\n                if mapping[char] != top_element:\n                    return False\n            else:\n                stack.append(char)\n\n        return not stack",
  "test_passed": true,
  "test_output": "============================= test session starts ==============================\nplatform darwin -- Python 3.14.3, pytest-9.0.2, pluggy-1.6.0\nrootdir: /private/test/llm_complexity_benchmark\nplugins: anyio-4.12.1\ncollected 3 items\n\n01_TestDefinitions/valid_parentheses_complex/test_solution.py ...        [100%]\n\n============================== 3 passed in 0.02s ===============================\n",
  "test_errors": "",
  "complexity_metrics": {
    "total_complexity_score": 0.2837,
    "python": {
      "cyclomatic_avg": 5.0,
      "cyclomatic_max": 5,
      "wmc": 5,
      "maintainability_index": 91.87909142523868,
      "max_nesting_depth": 5,
      "halstead_volume": 0,
      "lloc": 17,
      "loc": 29
    },
    "lisp": {
      "lisp_max_depth": 4,
      "lisp_constraints": 3,
      "lisp_rules": 1,
      "lisp_token_count": 81
    }
  }
}