{
  "task_name": "binary_tree_maximum_path_sum",
  "model": "gemma3:12b",
  "timestamp": "2026-02-20T15:20:54.620427",
  "nl_problem": "# Task: binary_tree_maximum_path_sum\n# Interface:\nClass: Solution\nMethod: maxPathSum(self, arg1)\n\nA path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root.\nThe path sum of a path is the sum of the node's values in the path.\nGiven the root of a binary tree, return the maximum path sum of any non-empty path.\n\nConstraints:\n- The number of nodes in the tree is in the range [1, 3 * 10^4].\n- -1000 <= Node.val <= 1000",
  "lisp_spec": "(task\n  (name \"maxPathSum\")\n  (signature ( (root (dict string int)) ) int)\n  (constraints\n    (constraint \"The number of nodes in the tree is in the range [1, 3 * 10^4].\")\n    (constraint \"-1000 <= Node.val <= 1000\")\n  )\n  (goal\n    (description \"Find the maximum path sum of any non-empty path in a binary tree.\")\n    (rule \"A path is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them.\")\n    (rule \"A node can only appear in the sequence at most once.\")\n    (rule \"The path does not need to pass through the root.\")\n    (return \"Return the maximum path sum found in the tree. If the tree is empty, return 0.\")\n  )\n)",
  "generated_code": "from typing import List, Optional, Dict, Set, Any\nimport heapq\nimport collections\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def maxPathSum(self, root: Dict[str, int]) -> int:\n        \"\"\"\n        Finds the maximum path sum of any non-empty path in a binary tree.\n\n        Args:\n            root: A dictionary representing the root of the binary tree.\n                  The keys are node values (integers), and the values are dictionaries\n                  representing the left and right children.  If a child is None,\n                  the corresponding key is absent.\n\n        Returns:\n            The maximum path sum found in the tree.\n        \"\"\"\n        max_sum = float('-inf')\n\n        def max_path_sum_helper(node: Optional[TreeNode]) -> int:\n            nonlocal max_sum\n            if not node:\n                return 0\n\n            left_sum = max(0, max_path_sum_helper(node.left))\n            right_sum = max(0, max_path_sum_helper(node.right))\n\n            max_sum = max(max_sum, node.val + left_sum + right_sum)\n\n            return node.val + max(left_sum, right_sum)\n\n        if root is None:\n            return 0\n\n        node = TreeNode(root['val'])\n        if 'left' in root:\n            node.left = TreeNode(root['left']['val'])\n            if 'left' in root['left']:\n                node.left.left = TreeNode(root['left']['left']['val'])\n            if 'right' in root['left']:\n                node.left.right = TreeNode(root['left']['right']['val'])\n        if 'right' in root:\n            node.right = TreeNode(root['right']['val'])\n            if 'left' in root['right']:\n                node.right.left = TreeNode(root['right']['left']['val'])\n            if 'right' in root['right']:\n                node.right.right = TreeNode(root['right']['right']['val'])\n\n        max_path_sum_helper(node)\n        return max_sum",
  "test_passed": false,
  "test_output": "============================= test session starts ==============================\nplatform darwin -- Python 3.14.3, pytest-9.0.2, pluggy-1.6.0\nrootdir: /private/test/llm_complexity_benchmark\nplugins: anyio-4.12.1\ncollected 2 items\n\n01_TestDefinitions/binary_tree_maximum_path_sum/test_solution.py FF      [100%]\n\n=================================== FAILURES ===================================\n___________________________ test_max_path_sum_basic ____________________________\n\n    def test_max_path_sum_basic():\n        solution = Solution()\n        root = TreeNode(1, TreeNode(2), TreeNode(3))\n>       assert solution.maxPathSum(root) == 6\n               ^^^^^^^^^^^^^^^^^^^^^^^^^\n\n01_TestDefinitions/binary_tree_maximum_path_sum/test_solution.py:13: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <solution.Solution object at 0x106a5b0e0>\nroot = <test_solution.TreeNode object at 0x106ac5090>\n\n    def maxPathSum(self, root: Dict[str, int]) -> int:\n        \"\"\"\n        Finds the maximum path sum of any non-empty path in a binary tree.\n    \n        Args:\n            root: A dictionary representing the root of the binary tree.\n                  The keys are node values (integers), and the values are dictionaries\n                  representing the left and right children.  If a child is None,\n                  the corresponding key is absent.\n    \n        Returns:\n            The maximum path sum found in the tree.\n        \"\"\"\n        max_sum = float('-inf')\n    \n        def max_path_sum_helper(node: Optional[TreeNode]) -> int:\n            nonlocal max_sum\n            if not node:\n                return 0\n    \n            left_sum = max(0, max_path_sum_helper(node.left))\n            right_sum = max(0, max_path_sum_helper(node.right))\n    \n            max_sum = max(max_sum, node.val + left_sum + right_sum)\n    \n            return node.val + max(left_sum, right_sum)\n    \n        if root is None:\n            return 0\n    \n>       node = TreeNode(root['val'])\n                        ^^^^^^^^^^^\nE       TypeError: 'TreeNode' object is not subscriptable\n\n01_TestDefinitions/binary_tree_maximum_path_sum/solution.py:42: TypeError\n__________________________ test_max_path_sum_negative __________________________\n\n    def test_max_path_sum_negative():\n        solution = Solution()\n        root = TreeNode(-10, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7)))\n        # Path: 15 -> 20 -> 7 => 42\n>       assert solution.maxPathSum(root) == 42\n               ^^^^^^^^^^^^^^^^^^^^^^^^^\n\n01_TestDefinitions/binary_tree_maximum_path_sum/test_solution.py:19: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <solution.Solution object at 0x106ac5310>\nroot = <test_solution.TreeNode object at 0x106aa6580>\n\n    def maxPathSum(self, root: Dict[str, int]) -> int:\n        \"\"\"\n        Finds the maximum path sum of any non-empty path in a binary tree.\n    \n        Args:\n            root: A dictionary representing the root of the binary tree.\n                  The keys are node values (integers), and the values are dictionaries\n                  representing the left and right children.  If a child is None,\n                  the corresponding key is absent.\n    \n        Returns:\n            The maximum path sum found in the tree.\n        \"\"\"\n        max_sum = float('-inf')\n    \n        def max_path_sum_helper(node: Optional[TreeNode]) -> int:\n            nonlocal max_sum\n            if not node:\n                return 0\n    \n            left_sum = max(0, max_path_sum_helper(node.left))\n            right_sum = max(0, max_path_sum_helper(node.right))\n    \n            max_sum = max(max_sum, node.val + left_sum + right_sum)\n    \n            return node.val + max(left_sum, right_sum)\n    \n        if root is None:\n            return 0\n    \n>       node = TreeNode(root['val'])\n                        ^^^^^^^^^^^\nE       TypeError: 'TreeNode' object is not subscriptable\n\n01_TestDefinitions/binary_tree_maximum_path_sum/solution.py:42: TypeError\n=========================== short test summary info ============================\nFAILED 01_TestDefinitions/binary_tree_maximum_path_sum/test_solution.py::test_max_path_sum_basic\nFAILED 01_TestDefinitions/binary_tree_maximum_path_sum/test_solution.py::test_max_path_sum_negative\n============================== 2 failed in 0.03s ===============================\n",
  "test_errors": "",
  "complexity_metrics": {
    "total_complexity_score": 0.3428,
    "python": {
      "cyclomatic_avg": 4.5,
      "cyclomatic_max": 8,
      "wmc": 9,
      "maintainability_index": 75.517901996897,
      "max_nesting_depth": 4,
      "halstead_volume": 0,
      "lloc": 37,
      "loc": 57
    },
    "lisp": {
      "lisp_max_depth": 5,
      "lisp_constraints": 3,
      "lisp_rules": 3,
      "lisp_token_count": 114
    }
  }
}