{
  "task_name": "fractional_knapsack",
  "model": "gemma3:12b",
  "timestamp": "2026-02-20T15:25:12.367879",
  "nl_problem": "# Task: fractional_knapsack\n# Interface:\nClass: Solution\nMethod: fractionalKnapsack(self, arg1, arg2)\n\nGiven a set of items, each with a weight and a value, and a knapsack of a given capacity, find the maximum total value you can carry. In the fractional knapsack problem, you can break items for maximizing the total value.\nItems are given as a list of pairs: `(value, weight)`.\n\nConstraints:\n- 1 <= n <= 10^5\n- 1 <= capacity <= 10^7\n- 1 <= value, weight <= 1000",
  "lisp_spec": "(task\n  (name \"fractionalKnapsack\")\n  (signature ( (items (list (tuple int int))) (capacity int) ) (float))\n  (constraints\n    (constraint \"The number of items (n) is between 1 and 10^5.\")\n    (constraint \"The knapsack capacity is between 1 and 10^7.\")\n    (constraint \"The value and weight of each item are between 1 and 1000.\")\n  )\n  (goal\n    (description \"Maximize the total value of items carried in the knapsack.\")\n    (rule \"Items can be broken into fractions to maximize the value.\")\n    (rule \"The total weight of items carried cannot exceed the knapsack capacity.\")\n    (return \"Return the maximum total value that can be carried in the knapsack as a float.\")\n  )\n)",
  "generated_code": "from typing import List, Tuple\nimport functools\n\nclass Solution:\n    def fractionalKnapsack(self, items: List[Tuple[int, int]], capacity: int) -> float:\n        \"\"\"\n        Calculates the maximum value that can be carried in a fractional knapsack.\n\n        Args:\n            items: A list of tuples, where each tuple represents an item and contains (value, weight).\n            capacity: The capacity of the knapsack.\n\n        Returns:\n            The maximum total value that can be carried in the knapsack as a float.\n        \"\"\"\n        # Calculate value-to-weight ratio for each item\n        value_per_weight = [(value / weight, weight) for value, weight in items]\n\n        # Sort items by value-to-weight ratio in descending order\n        value_per_weight.sort(reverse=True)\n\n        total_value = 0.0\n        remaining_capacity = capacity\n\n        for value_per_unit, weight in value_per_unit:\n            if weight <= remaining_capacity:\n                total_value += value_per_unit * weight\n                remaining_capacity -= weight\n            else:\n                total_value += value_per_unit * remaining_capacity\n                remaining_capacity = 0\n                break\n\n        return total_value",
  "test_passed": false,
  "test_output": "============================= test session starts ==============================\nplatform darwin -- Python 3.14.3, pytest-9.0.2, pluggy-1.6.0\nrootdir: /private/test/llm_complexity_benchmark\nplugins: anyio-4.12.1\ncollected 2 items\n\n01_TestDefinitions/fractional_knapsack/test_solution.py FF               [100%]\n\n=================================== FAILURES ===================================\n________________________ test_fractional_knapsack_basic ________________________\n\n    def test_fractional_knapsack_basic():\n        solution = Solution()\n        items = [(60, 10), (100, 20), (120, 30)]\n        capacity = 50\n        # Items (val/weight): (6,10), (5,20), (4,30)\n        # Take all of item1 (60) and item2 (100) and 2/3 of item3 (80) -> 240\n>       assert solution.fractionalKnapsack(items, capacity) == 240.0\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n01_TestDefinitions/fractional_knapsack/test_solution.py:10: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <solution.Solution object at 0x102cab0e0>\nitems = [(60, 10), (100, 20), (120, 30)], capacity = 50\n\n    def fractionalKnapsack(self, items: List[Tuple[int, int]], capacity: int) -> float:\n        \"\"\"\n        Calculates the maximum value that can be carried in a fractional knapsack.\n    \n        Args:\n            items: A list of tuples, where each tuple represents an item and contains (value, weight).\n            capacity: The capacity of the knapsack.\n    \n        Returns:\n            The maximum total value that can be carried in the knapsack as a float.\n        \"\"\"\n        # Calculate value-to-weight ratio for each item\n        value_per_weight = [(value / weight, weight) for value, weight in items]\n    \n        # Sort items by value-to-weight ratio in descending order\n        value_per_weight.sort(reverse=True)\n    \n        total_value = 0.0\n        remaining_capacity = capacity\n    \n>       for value_per_unit, weight in value_per_unit:\n                                      ^^^^^^^^^^^^^^\nE       UnboundLocalError: cannot access local variable 'value_per_unit' where it is not associated with a value\n\n01_TestDefinitions/fractional_knapsack/solution.py:25: UnboundLocalError\n________________________ test_fractional_knapsack_empty ________________________\n\n    def test_fractional_knapsack_empty():\n        solution = Solution()\n>       assert solution.fractionalKnapsack([], 10) == 0.0\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n01_TestDefinitions/fractional_knapsack/test_solution.py:14: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <solution.Solution object at 0x102d15310>, items = [], capacity = 10\n\n    def fractionalKnapsack(self, items: List[Tuple[int, int]], capacity: int) -> float:\n        \"\"\"\n        Calculates the maximum value that can be carried in a fractional knapsack.\n    \n        Args:\n            items: A list of tuples, where each tuple represents an item and contains (value, weight).\n            capacity: The capacity of the knapsack.\n    \n        Returns:\n            The maximum total value that can be carried in the knapsack as a float.\n        \"\"\"\n        # Calculate value-to-weight ratio for each item\n        value_per_weight = [(value / weight, weight) for value, weight in items]\n    \n        # Sort items by value-to-weight ratio in descending order\n        value_per_weight.sort(reverse=True)\n    \n        total_value = 0.0\n        remaining_capacity = capacity\n    \n>       for value_per_unit, weight in value_per_unit:\n                                      ^^^^^^^^^^^^^^\nE       UnboundLocalError: cannot access local variable 'value_per_unit' where it is not associated with a value\n\n01_TestDefinitions/fractional_knapsack/solution.py:25: UnboundLocalError\n=========================== short test summary info ============================\nFAILED 01_TestDefinitions/fractional_knapsack/test_solution.py::test_fractional_knapsack_basic\nFAILED 01_TestDefinitions/fractional_knapsack/test_solution.py::test_fractional_knapsack_empty\n============================== 2 failed in 0.03s ===============================\n",
  "test_errors": "",
  "complexity_metrics": {
    "total_complexity_score": 0.2904,
    "python": {
      "cyclomatic_avg": 4.0,
      "cyclomatic_max": 4,
      "wmc": 4,
      "maintainability_index": 88.03911882250972,
      "max_nesting_depth": 4,
      "halstead_volume": 0,
      "lloc": 18,
      "loc": 34
    },
    "lisp": {
      "lisp_max_depth": 6,
      "lisp_constraints": 4,
      "lisp_rules": 2,
      "lisp_token_count": 102
    }
  }
}