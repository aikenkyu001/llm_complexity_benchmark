{
  "task_name": "word_ladder",
  "model": "gemma3:12b",
  "timestamp": "2026-02-20T16:06:23.991979",
  "nl_problem": "# Task: Word Ladder\n# Interface:\nClass: Solution\nMethod: ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int\n\n# Objective:\nA transformation sequence from word `beginWord` to word `endWord` using a dictionary `wordList` is a sequence of words `beginWord -> s1 -> s2 -> ... -> sk` such that:\n- Every adjacent pair of words differs by a single letter.\n- Every `si` for `1 <= i <= sk` is in `wordList`. Note that `beginWord` does not need to be in `wordList`.\n- `sk == endWord`.\nGiven two words, `beginWord` and `endWord`, and a dictionary `wordList`, return the number of words in the shortest transformation sequence from `beginWord` to `endWord`, or 0 if no such sequence exists.\n\n# Strategy Hint:\nUse Breadth-First Search (BFS) to find the shortest path. To efficiently find neighbors, consider pre-processing the word list or checking words with one-letter variations.\n\n# Constraints:\n- 1 <= beginWord.length <= 10\n- endWord.length == beginWord.length\n- 1 <= wordList.length <= 5000\n- wordList[i].length == beginWord.length\n- beginWord, endWord, and wordList[i] consist of lowercase English letters.\n- beginWord != endWord\n- All words in wordList are unique.",
  "lisp_spec": "(task\n  (name \"ladderLength\")\n  (signature ( (beginWord string) (endWord string) (wordList list) ) int))\n  (constraints\n    (constraint \"beginWord.length is between 1 and 10\")\n    (constraint \"endWord.length == beginWord.length\")\n    (constraint \"wordList.length is between 1 and 5000\")\n    (constraint \"wordList[i].length == beginWord.length\")\n    (constraint \"beginWord, endWord, and wordList[i] consist of lowercase English letters.\")\n    (constraint \"beginWord != endWord\")\n    (constraint \"All words in wordList are unique.\")\n  )\n  (goal\n    (description \"Find the length of the shortest transformation sequence from beginWord to endWord using words from wordList, where each adjacent word differs by one letter.\")\n    (rule \"Each word in the sequence must differ from the previous word by exactly one letter.\")\n    (rule \"Each word in the sequence (except beginWord) must be present in wordList.\")\n    (rule \"The last word in the sequence must be endWord.\")\n    (return \"Return the number of words in the shortest transformation sequence. If no such sequence exists, return 0.\")\n  )\n)",
  "generated_code": "from typing import List, Optional, Dict, Set, Any\nimport heapq\nimport collections\n\nclass Solution:\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\n        \"\"\"\n        Finds the length of the shortest transformation sequence from beginWord to endWord using words from wordList.\n\n        Args:\n            beginWord: The starting word.\n            endWord: The target word.\n            wordList: A list of valid words.\n\n        Returns:\n            The length of the shortest transformation sequence. Returns 0 if no such sequence exists.\n        \"\"\"\n\n        if endWord not in wordList:\n            return 0\n\n        wordSet = set(wordList)\n        queue = collections.deque([(beginWord, 1)])  # (word, level)\n        visited = {beginWord}\n\n        while queue:\n            word, level = queue.popleft()\n\n            if word == endWord:\n                return level\n\n            for i in range(len(word)):\n                for char_code in range(ord('a'), ord('z') + 1):\n                    new_word = word[:i] + chr(char_code) + word[i+1:]\n\n                    if new_word in wordSet and new_word not in visited:\n                        queue.append((new_word, level + 1))\n                        visited.add(new_word)\n\n        return 0",
  "test_passed": false,
  "test_output": "============================= test session starts ==============================\nplatform darwin -- Python 3.14.3, pytest-9.0.2, pluggy-1.6.0\nrootdir: /private/test/llm_complexity_benchmark\nplugins: anyio-4.12.1\ncollected 5 items\n\n01_TestDefinitions/word_ladder/test_solution.py ..F..                    [100%]\n\n=================================== FAILURES ===================================\n__________________________ test_word_ladder_same_word __________________________\n\n    def test_word_ladder_same_word():\n        \"\"\"\n        Test a case where begin and end words are the same.\n        \"\"\"\n        solution = Solution()\n        beginWord = \"hit\"\n        endWord = \"hit\"\n        wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\n        expected = 1\n>       assert solution.ladderLength(beginWord, endWord, wordList) == expected\nE       AssertionError: assert 0 == 1\nE        +  where 0 = ladderLength('hit', 'hit', ['hot', 'dot', 'dog', 'lot', 'log', 'cog'])\nE        +    where ladderLength = <solution.Solution object at 0x104e0d310>.ladderLength\n\n01_TestDefinitions/word_ladder/test_solution.py:35: AssertionError\n=========================== short test summary info ============================\nFAILED 01_TestDefinitions/word_ladder/test_solution.py::test_word_ladder_same_word\n========================= 1 failed, 4 passed in 0.03s ==========================\n",
  "test_errors": "",
  "complexity_metrics": {
    "total_complexity_score": 0.4986,
    "python": {
      "cyclomatic_avg": 8.0,
      "cyclomatic_max": 8,
      "wmc": 8,
      "maintainability_index": 83.19171188103155,
      "max_nesting_depth": 6,
      "halstead_volume": 0,
      "lloc": 23,
      "loc": 40
    },
    "lisp": {
      "lisp_max_depth": 4,
      "lisp_constraints": 8,
      "lisp_rules": 3,
      "lisp_token_count": 143
    }
  }
}