{
  "task_name": "activity_selection",
  "model": "gemma3:12b",
  "timestamp": "2026-02-20T15:18:38.224743",
  "nl_problem": "# Task: activity_selection\n# Interface:\nClass: Solution\nMethod: maxActivities(self, arg1)\n\nYou are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person, assuming that a person can only work on a single activity at a time.\nInput is a list of pairs `(start, finish)`.\n\nConstraints:\n- 1 <= n <= 10^5\n- 0 <= start < finish <= 10^9",
  "lisp_spec": "(task\n  (name \"maxActivities\")\n  (signature ( (activities (list (pair int int))) ) int)\n  (constraints\n    (constraint \"The number of activities (n) is between 1 and 10^5.\")\n    (constraint \"Start times and finish times are non-negative integers.\")\n    (constraint \"For each activity, start time is less than finish time.\")\n    (constraint \"Start and finish times are within the range [0, 10^9].\")\n  )\n  (goal\n    (description \"Select the maximum number of non-overlapping activities from the given list.\")\n    (rule \"Sort the activities based on their finish times in ascending order.\")\n    (rule \"Select the first activity. Then, iterate through the remaining activities and select an activity if its start time is greater than or equal to the finish time of the last selected activity.\")\n    (return \"Return the count of selected activities.\")\n  )\n)",
  "generated_code": "from typing import List, Optional, Dict, Set, Any\nimport heapq\nimport collections\n\nclass Solution:\n    def maxActivities(self, activities: List[List[int]]) -> int:\n        \"\"\"\n        Selects the maximum number of non-overlapping activities from the given list.\n\n        Args:\n            activities: A list of activities, where each activity is a pair of (start_time, finish_time).\n\n        Returns:\n            The count of selected activities.\n        \"\"\"\n        # Sort activities based on their finish times in ascending order.\n        activities.sort(key=lambda x: x[1])\n\n        # Select the first activity.\n        selected_activities = 1\n        last_finish_time = activities[0][1]\n\n        # Iterate through the remaining activities and select an activity if its start time is greater than or equal to the finish time of the last selected activity.\n        for i in range(1, len(activities)):\n            if activities[i][0] >= last_finish_time:\n                selected_activities += 1\n                last_finish_time = activities[i][1]\n\n        return selected_activities",
  "test_passed": true,
  "test_output": "============================= test session starts ==============================\nplatform darwin -- Python 3.14.3, pytest-9.0.2, pluggy-1.6.0\nrootdir: /private/test/llm_complexity_benchmark\nplugins: anyio-4.12.1\ncollected 2 items\n\n01_TestDefinitions/activity_selection/test_solution.py ..                [100%]\n\n============================== 2 passed in 0.02s ===============================\n",
  "test_errors": "",
  "complexity_metrics": {
    "total_complexity_score": 0.30210000000000004,
    "python": {
      "cyclomatic_avg": 3.0,
      "cyclomatic_max": 3,
      "wmc": 3,
      "maintainability_index": 93.82579550747367,
      "max_nesting_depth": 4,
      "halstead_volume": 0,
      "lloc": 15,
      "loc": 29
    },
    "lisp": {
      "lisp_max_depth": 6,
      "lisp_constraints": 5,
      "lisp_rules": 2,
      "lisp_token_count": 123
    }
  }
}