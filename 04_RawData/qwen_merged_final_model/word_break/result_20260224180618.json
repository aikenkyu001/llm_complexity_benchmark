{
  "task_name": "word_break",
  "model": "qwen_merged_final_model",
  "timestamp": "2026-02-24T18:06:18.441625",
  "nl_problem": "# Task: word_break\n# Interface:\nClass: Solution\nMethod: wordBreak(self, arg1, arg2, arg3)\n\nGiven a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of one or more dictionary words.\nNote that the same word in the dictionary may be reused multiple times in the segmentation.\n\nConstraints:\n- 1 <= s.length <= 300\n- 1 <= wordDict.length <= 1000\n- 1 <= wordDict[i].length <= 20\n- s and wordDict[i] consist of only lowercase English letters.\n- All strings in wordDict are unique.",
  "lisp_spec": "(task\n  (name \"wordBreak\")\n  (signature ( (s str) (wordDict list) ) bool)\n  (constraints\n    (constraint \"1 <= s.length <= 300\")\n    (constraint \"1 <= wordDict.length <= 1000\")\n    (constraint \"1 <= wordDict[i].length <= 20\")\n    (constraint \"s and wordDict[i] consist of only lowercase English letters.\")\n    (constraint \"All strings in wordDict are unique.\")\n  )\n  (goal\n    (description \"Return true if s can be segmented into a space-separated sequence of one or more dictionary words.\")\n    (rule \"The same word in the dictionary may be reused multiple times in the segmentation.\")\n    (return \"True if the string can be segmented; otherwise, false.\")\n  ))",
  "generated_code": "# solution.py\nfrom typing import List, Optional, Dict, Set, Any\nimport heapq\nimport collections\n\n# Define any helper classes here if needed\n\nclass Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\n        # Implement the wordBreak function here\n        n = len(s)\n        dp = [False] * (n + 1)\n        dp[0] = True\n        \n        for i in range(1, n + 1):\n            for word in wordDict:\n                if i >= len(word) and dp[i - len(word)] and s[i - len(word):i] == word:\n                    dp[i] = True\n                    break\n        \n        return dp[n]",
  "test_passed": true,
  "test_output": "============================= test session starts ==============================\nplatform linux -- Python 3.12.3, pytest-9.0.2, pluggy-1.6.0\nrootdir: /home/miyata/projects/llm_complexity_benchmark\nplugins: anyio-4.12.1\ncollected 4 items\n\n01_TestDefinitions/word_break/test_solution.py ....                      [100%]\n\n============================== 4 passed in 0.02s ===============================\n",
  "complexity_metrics": {
    "total_complexity_score": 0.35860000000000003,
    "python": {
      "cyclomatic_avg": 6.0,
      "cyclomatic_max": 6,
      "wmc": 6,
      "maintainability_index": 83.80929719169545,
      "max_nesting_depth": 5,
      "halstead_volume": 0,
      "lloc": 14,
      "loc": 21
    },
    "lisp": {
      "lisp_max_depth": 4,
      "lisp_constraints": 6,
      "lisp_rules": 1,
      "lisp_token_count": 93
    }
  }
}