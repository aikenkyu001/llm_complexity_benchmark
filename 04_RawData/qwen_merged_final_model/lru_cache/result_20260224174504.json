{
  "task_name": "lru_cache",
  "model": "qwen_merged_final_model",
  "timestamp": "2026-02-24T17:45:04.270225",
  "nl_problem": "# Task: LRU Cache\n# Interface:\nClass: Solution\nMethod: LRUCache(self, capacity: int) -> 'LRUCache'\n\nDesign a data structure that follows the constraints of a Least Recently Used (LRU) cache.\n\nImplement the LRUCache class:\n- `LRUCache(int capacity)`: Initialize the LRU cache with positive size capacity.\n- `int get(int key)`: Return the value of the key if the key exists, otherwise return -1.\n- `void put(int key, int value)`: Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.\n\nThe functions `get` and `put` must each run in O(1) average time complexity.\nYou must not use the built-in `collections.OrderedDict`. You should use a combination of a hash map and a double linked list to achieve the required time complexity.",
  "lisp_spec": "(task\n  (name \"LRUCache\")\n  (signature ( (capacity int) ) 'LRUCache)\n  (constraints\n    (constraint \"The LRUCache class should implement the following methods:\")\n    (constraint \"get(key): Returns the value of the key if the key exists, otherwise returns -1.\")\n    (constraint \"put(key, value): Updates the value of the key if the key exists. Otherwise, adds the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evicts the least recently used key.\")\n    (constraint \"Both get and put must run in O(1) average time complexity.\")\n    (constraint \"You must not use the built-in collections.OrderedDict.\")\n    (constraint \"You should use a combination of a hash map and a double linked list to achieve the required time complexity.\")\n  )\n  (goal\n    (description \"Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.\")\n    (rule \"The LRUCache class should have the following methods:\")\n    (rule \"get(key): Returns the value of the key if the key exists, otherwise returns -1.\")\n    (rule \"put(key, value): Updates the value of the key if the key exists. Otherwise, adds the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evicts the least recently used key.\")\n    (rule \"Both get and put must run in O(1) average time complexity.\")\n    (rule \"You must not use the built-in collections.OrderedDict.\")\n    (rule \"You should use a combination of a hash map and a double linked list to achieve the required time complexity.\")\n    (return \"The LRUCache class should be implemented according to the given constraints.\")\n  ))",
  "generated_code": "# solution.py\nfrom typing import List, Optional, Dict, Set, Any\nimport heapq\nimport collections\n\n# Define any helper classes here if needed\n\nclass Node:\n    def __init__(self, key: int, value: int):\n        self.key = key\n        self.value = value\n        self.prev = None\n        self.next = None\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = {}\n        self.head = Node(0, 0)\n        self.tail = Node(0, 0)\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        node = self.cache[key]\n        self._remove(node)\n        self._add(node)\n        return node.value\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            self._remove(self.cache[key])\n        node = Node(key, value)\n        self._add(node)\n        self.cache[key] = node\n        if len(self.cache) > self.capacity:\n            node_to_remove = self.head.next\n            self._remove(node_to_remove)\n            del self.cache[node_to_remove.key]\n\n    def _remove(self, node: Node) -> None:\n        prev = node.prev\n        next = node.next\n        prev.next = next\n        next.prev = prev\n\n    def _add(self, node: Node) -> None:\n        prev = self.tail.prev\n        prev.next = node\n        node.prev = prev\n        node.next = self.tail\n        self.tail.prev = node\n\nclass Solution:\n    def LRUCache(self, capacity: int) -> LRUCache:\n        return LRUCache(capacity)",
  "test_passed": true,
  "test_output": "============================= test session starts ==============================\nplatform linux -- Python 3.12.3, pytest-9.0.2, pluggy-1.6.0\nrootdir: /home/miyata/projects/llm_complexity_benchmark\nplugins: anyio-4.12.1\ncollected 3 items\n\n01_TestDefinitions/lru_cache/test_solution.py ...                        [100%]\n\n============================== 3 passed in 0.03s ===============================\n",
  "complexity_metrics": {
    "total_complexity_score": 0.4219,
    "python": {
      "cyclomatic_avg": 1.4285714285714286,
      "cyclomatic_max": 3,
      "wmc": 10,
      "maintainability_index": 62.781798071706795,
      "max_nesting_depth": 3,
      "halstead_volume": 0,
      "lloc": 48,
      "loc": 58
    },
    "lisp": {
      "lisp_max_depth": 4,
      "lisp_constraints": 7,
      "lisp_rules": 6,
      "lisp_token_count": 247
    }
  }
}