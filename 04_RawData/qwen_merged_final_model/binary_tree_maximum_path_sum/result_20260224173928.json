{
  "task_name": "binary_tree_maximum_path_sum",
  "model": "qwen_merged_final_model",
  "timestamp": "2026-02-24T17:39:28.618160",
  "nl_problem": "# Task: binary_tree_maximum_path_sum\n# Interface:\nClass: Solution\nMethod: maxPathSum(self, arg1)\n\nA path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root.\nThe path sum of a path is the sum of the node's values in the path.\nGiven the root of a binary tree, return the maximum path sum of any non-empty path.\n\nConstraints:\n- The number of nodes in the tree is in the range [1, 3 * 10^4].\n- -1000 <= Node.val <= 1000",
  "lisp_spec": "(task\n  (name \"maxPathSum\")\n  (signature ( (arg1 TreeNode) ) int)\n  (constraints\n    (constraint \"The number of nodes in the tree is in the range [1, 3 * 10^4].\")\n    (constraint \"-1000 <= Node.val <= 1000\")\n  )\n  (goal\n    (description \"Return the maximum path sum of any non-empty path in the binary tree.\")\n    (rule \"A path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them.\")\n    (rule \"A node can only appear in the sequence at most once.\")\n    (rule \"The path does not need to pass through the root.\")\n    (rule \"The path sum of a path is the sum of the node's values in the path.\")\n    (return \"The maximum path sum of any non-empty path in the binary tree.\")\n  ))",
  "generated_code": "# solution.py\nfrom typing import List, Optional, Dict, Set, Any\nimport heapq\nimport collections\n\n# Define any helper classes here if needed\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\n        def dfs(node):\n            if not node:\n                return 0\n            \n            # Recursively find the maximum path sum for the left and right subtrees\n            left_max = max(dfs(node.left), 0)\n            right_max = max(dfs(node.right), 0)\n            \n            # The maximum path sum through the current node\n            current_max_path_sum = node.val + left_max + right_max\n            \n            # Update the global maximum path sum\n            self.global_max = max(self.global_max, current_max_path_sum)\n            \n            # Return the maximum path sum that can be extended upwards\n            return node.val + max(left_max, right_max)\n        \n        # Initialize the global maximum path sum\n        self.global_max = float('-inf')\n        \n        # Start DFS from the root\n        dfs(root)\n        \n        return self.global_max",
  "test_passed": true,
  "test_output": "============================= test session starts ==============================\nplatform linux -- Python 3.12.3, pytest-9.0.2, pluggy-1.6.0\nrootdir: /home/miyata/projects/llm_complexity_benchmark\nplugins: anyio-4.12.1\ncollected 2 items\n\n01_TestDefinitions/binary_tree_maximum_path_sum/test_solution.py ..      [100%]\n\n============================== 2 passed in 0.02s ===============================\n",
  "complexity_metrics": {
    "total_complexity_score": 0.2781,
    "python": {
      "cyclomatic_avg": 1.0,
      "cyclomatic_max": 1,
      "wmc": 2,
      "maintainability_index": 88.12403717852774,
      "max_nesting_depth": 4,
      "halstead_volume": 0,
      "lloc": 21,
      "loc": 39
    },
    "lisp": {
      "lisp_max_depth": 4,
      "lisp_constraints": 3,
      "lisp_rules": 4,
      "lisp_token_count": 128
    }
  }
}